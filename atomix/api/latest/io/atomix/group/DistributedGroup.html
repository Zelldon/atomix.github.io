<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!-- NewPage -->
<html lang="en">
<head>
<!-- Generated by javadoc -->
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>DistributedGroup (Atomix API Reference (latest))</title>
<link rel="stylesheet" type="text/css" href="../../../stylesheet.css" title="Style">
<script type="text/javascript" src="../../../script.js"></script>
</head>
<body>
<script type="text/javascript"><!--
    try {
        if (location.href.indexOf('is-external=true') == -1) {
            parent.document.title="DistributedGroup (Atomix API Reference (latest))";
        }
    }
    catch(err) {
    }
//-->
var methods = {"i0":6,"i1":6,"i2":6,"i3":6,"i4":6,"i5":6,"i6":6,"i7":6,"i8":6,"i9":6,"i10":6};
var tabs = {65535:["t0","All Methods"],2:["t2","Instance Methods"],4:["t3","Abstract Methods"]};
var altColor = "altColor";
var rowColor = "rowColor";
var tableTab = "tableTab";
var activeTableTab = "activeTableTab";
</script>
<noscript>
<div>JavaScript is disabled on your browser.</div>
</noscript>
<!-- ========= START OF TOP NAVBAR ======= -->
<div class="topNav"><a name="navbar.top">
<!--   -->
</a>
<div class="skipNav"><a href="#skip.navbar.top" title="Skip navigation links">Skip navigation links</a></div>
<a name="navbar.top.firstrow">
<!--   -->
</a>
<ul class="navList" title="Navigation">
<li><a href="../../../overview-summary.html">Overview</a></li>
<li><a href="package-summary.html">Package</a></li>
<li class="navBarCell1Rev">Class</li>
<li><a href="class-use/DistributedGroup.html">Use</a></li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../../../deprecated-list.html">Deprecated</a></li>
<li><a href="../../../index-all.html">Index</a></li>
<li><a href="../../../help-doc.html">Help</a></li>
</ul>
</div>
<div class="subNav">
<ul class="navList">
<li>Prev&nbsp;Class</li>
<li><a href="../../../io/atomix/group/DistributedGroup.Config.html" title="class in io.atomix.group"><span class="typeNameLink">Next&nbsp;Class</span></a></li>
</ul>
<ul class="navList">
<li><a href="../../../index.html?io/atomix/group/DistributedGroup.html" target="_top">Frames</a></li>
<li><a href="DistributedGroup.html" target="_top">No&nbsp;Frames</a></li>
</ul>
<ul class="navList" id="allclasses_navbar_top">
<li><a href="../../../allclasses-noframe.html">All&nbsp;Classes</a></li>
</ul>
<div>
<script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_top");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script>
</div>
<div>
<ul class="subNavList">
<li>Summary:&nbsp;</li>
<li><a href="#nested.class.summary">Nested</a>&nbsp;|&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li>Constr&nbsp;|&nbsp;</li>
<li><a href="#method.summary">Method</a></li>
</ul>
<ul class="subNavList">
<li>Detail:&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li>Constr&nbsp;|&nbsp;</li>
<li><a href="#method.detail">Method</a></li>
</ul>
</div>
<a name="skip.navbar.top">
<!--   -->
</a></div>
<!-- ========= END OF TOP NAVBAR ========= -->
<!-- ======== START OF CLASS DATA ======== -->
<div class="header">
<div class="subTitle">io.atomix.group</div>
<h2 title="Interface DistributedGroup" class="title">Interface DistributedGroup</h2>
</div>
<div class="contentContainer">
<div class="description">
<ul class="blockList">
<li class="blockList">
<dl>
<dt>All Superinterfaces:</dt>
<dd><a href="http://atomix.io/catalyst/api/latest/io/atomix/catalyst/util/Managed.html?is-external=true" title="class or interface in io.atomix.catalyst.util">Managed</a>&lt;<a href="../../../io/atomix/group/DistributedGroup.html" title="interface in io.atomix.group">DistributedGroup</a>&gt;, <a href="../../../io/atomix/resource/Resource.html" title="interface in io.atomix.resource">Resource</a>&lt;<a href="../../../io/atomix/group/DistributedGroup.html" title="interface in io.atomix.group">DistributedGroup</a>&gt;</dd>
</dl>
<hr>
<br>
<pre>public interface <span class="typeNameLabel">DistributedGroup</span>
extends <a href="../../../io/atomix/resource/Resource.html" title="interface in io.atomix.resource">Resource</a>&lt;<a href="../../../io/atomix/group/DistributedGroup.html" title="interface in io.atomix.group">DistributedGroup</a>&gt;</pre>
<div class="block">Generic group abstraction for managing group membership, service discovery, leader election, and remote
 scheduling and execution.
 <p>
 The distributed group resource facilitates managing group membership within an Atomix cluster. Membership is
 managed by nodes <a href="../../../io/atomix/group/DistributedGroup.html#join--"><code>joining</code></a> and <a href="../../../io/atomix/group/LocalMember.html#leave--"><code>leaving</code></a> the group, and instances
 of the group throughout the cluster are notified on changes to the structure of the group. Groups can elect a
 leader, and members can communicate directly with one another or through persistent queues.
 <p>
 Groups membership is managed in a replicated state machine. When a member joins the group, the join request
 is replicated, the member is added to the group, and the state machine notifies instances of the
 <code>DistributedGroup</code> of the membership change. In the event that a group instance becomes disconnected from
 the cluster and its session times out, the replicated state machine will automatically remove the member
 from the group and notify the remaining instances of the group of the membership change.
 <p>
 To create a membership group resource, use the <code>DistributedGroup</code> class or constructor:
 <pre>
   <code>
   atomix.getGroup("my-group").thenAccept(group -&gt; {
     ...
   });
   </code>
 </pre>
 <h2>Joining the group</h2>
 When a new instance of the resource is created, it is initialized with an empty <a href="../../../io/atomix/group/DistributedGroup.html#members--"><code>members()</code></a> list
 as it is not yet a member of the group. Once the instance has been created, the user must join the group
 via <a href="../../../io/atomix/group/DistributedGroup.html#join--"><code>join()</code></a>:
 <pre>
   <code>
   group.join().thenAccept(member -&gt; {
     System.out.println("Joined with member ID: " + member.id());
   });
   </code>
 </pre>
 Once the group has been joined, the <a href="../../../io/atomix/group/DistributedGroup.html#members--"><code>members()</code></a> list provides an up-to-date view of the group which will
 be automatically updated as members join and leave the group. To be explicitly notified when a member joins or
 leaves the group, use the <a href="../../../io/atomix/group/DistributedGroup.html#onJoin-java.util.function.Consumer-"><code>onJoin(Consumer)</code></a> or <a href="../../../io/atomix/group/DistributedGroup.html#onLeave-java.util.function.Consumer-"><code>onLeave(Consumer)</code></a> event consumers respectively:
 <pre>
   <code>
   group.onJoin(member -&gt; {
     System.out.println(member.id() + " joined the group!");
   });
   </code>
 </pre>
 <h2>Listing the members in the group</h2>
 Users of the distributed group do not have to join the group to interact with it. For instance, while a server
 may participate in the group by joining it, a client may interact with the group just to get a list of available
 members. To access the list of group members, use the <a href="../../../io/atomix/group/DistributedGroup.html#members--"><code>members()</code></a> getter:
 <pre>
   <code>
   DistributedGroup group = atomix.getGroup("foo").get();
   for (GroupMember member : group.members()) {
     ...
   }
   </code>
 </pre>
 Once the group instance has been created, the group membership will be automatically updated each time the structure
 of the group changes. However, in the event that the client becomes disconnected from the cluster, it may not receive
 notifications of changes in the group structure.
 <h2>Persistent members</h2>
 <code>DistributedGroup</code> supports a concept of persistent members that requires members to <em>explicitly</em>
 <a href="../../../io/atomix/group/LocalMember.html#leave--"><code>leave</code></a> the group to be removed from it. Persistent member <a href="../../../io/atomix/group/messaging/Message.html" title="interface in io.atomix.group.messaging"><code>tasks</code></a> will remain
 in a failed member's queue until the member recovers.
 <p>
 In order to support recovery, persistent members must be configured with a user-provided <a href="../../../io/atomix/group/GroupMember.html#id--"><code>member ID</code></a>.
 The member ID is provided when the member <a href="../../../io/atomix/group/DistributedGroup.html#join-java.lang.String-"><code>joins</code></a> the group, and providing a member ID is
 all that's required to create a persistent member.
 <pre>
   <code>
   DistributedGroup group = atomix.getGroup("persistent-members").get();
   LocalGroupMember memberA = group.join("a").get();
   LocalGroupMember memberB = group.join("b").get();
   </code>
 </pre>
 Persistent members are not limited to a single node. If a node crashes, any persistent members that existed
 on that node may rejoin the group on any other node. Persistent members rejoin simply by calling <a href="../../../io/atomix/group/DistributedGroup.html#join-java.lang.String-"><code>join(String)</code></a>
 with the unique member ID. Once a persistent member has rejoined the group, its session will be updated and any
 tasks remaining in the member's <a href="../../../io/atomix/group/messaging/MessageService.html" title="interface in io.atomix.group.messaging"><code>MessageService</code></a> will be published to the member.
 <p>
 Persistent member state is retained <em>only</em> inside the group's replicated state machine and not on clients.
 From the perspective of <code>DistributedGroup</code> instances in a cluster, in the event that the node on which
 a persistent member is running fails, the member will <a href="../../../io/atomix/group/DistributedGroup.html#onLeave-java.util.function.Consumer-"><code>leave</code></a> the group. Once the persistent
 member rejoins the group, <a href="../../../io/atomix/group/DistributedGroup.html#onJoin-java.util.function.Consumer-"><code>onJoin(Consumer)</code></a> will be called again on each group instance in the cluster.
 <h2>Leader election</h2>
 The <code>DistributedGroup</code> resource facilitates leader election which can be used to coordinate a group by
 ensuring only a single member of the group performs some set of operations at any given time. Leader election
 is a core concept of membership groups, and because leader election is a low-overhead process, leaders are
 elected for each group automatically.
 <p>
 Leaders are elected using a fair policy. The first member to <a href="../../../io/atomix/group/DistributedGroup.html#join--"><code>join</code></a> a group will always become the
 initial group leader. Each unique leader in a group is associated with a <a href="../../../io/atomix/group/election/Election.html#term--"><code>term</code></a>. The term
 represents a globally unique, monotonically increasing token that can be used for fencing. Users can listen for
 changes in group terms and leaders with event listeners:
 <pre>
   <code>
   DistributedGroup group = atomix.getGroup("election-group").get();
   group.election().onElection(term -&gt; {
     ...
   });
   </code>
 </pre>
 The <a href="../../../io/atomix/group/election/Term.html#term--"><code>term</code></a> is guaranteed to be unique for each <a href="../../../io/atomix/group/election/Term.html#leader--"><code>leader</code></a> and is
 guaranteed to be monotonically increasing. Each instance of a group is guaranteed to see the same leader for the
 same term, and no two leaders can ever exist in the same term. In that sense, the terminology and constraints of
 leader election in Atomix borrow heavily from the Raft consensus algorithm that underlies it.
 <h2>Messaging</h2>
 Members of a group and group instances can communicate with one another through the messaging API,
 <a href="../../../io/atomix/group/messaging/MessageService.html" title="interface in io.atomix.group.messaging"><code>MessageService</code></a>. Direct messaging between group members is reliable and is done as writes to the Atomix cluster.
 Messages are held in memory within the Atomix cluster and are published to consumers using Copycat's session event
 framework. Messages are guaranteed to be delivered to consumers in the order in which they were sent by a producer.
 Because each message is dependent on at least one or more writes to the Atomix cluster, messaging is not intended
 to support high-throughput use cases. Group messaging is designed for coordinating group behaviors. For example,
 a leader can instruct a random member to perform a task through the messaging API.
 <h3>Direct messaging</h3>
 To send messages directly to a specific member of the group, use the associated <a href="../../../io/atomix/group/GroupMember.html" title="interface in io.atomix.group"><code>GroupMember</code></a>'s
 <a href="../../../io/atomix/group/messaging/MessageClient.html" title="interface in io.atomix.group.messaging"><code>MessageClient</code></a>.
 <pre>
   <code>
   GroupMember member = group.member("foo");
   MessageProducer&lt;String&gt; producer = member.messaging().producer("bar");
   producer.send("baz").thenRun(() -&gt; {
     // Message acknowledged
   });
   </code>
 </pre>
 Users can specify the criteria by which a producer determines when a message is completed by configuring the
 producer's <a href="../../../io/atomix/group/messaging/MessageProducer.Execution.html" title="enum in io.atomix.group.messaging"><code>Execution</code></a> policy. To configure the execution
 policy, pass <a href="../../../io/atomix/group/messaging/MessageProducer.Options.html" title="class in io.atomix.group.messaging"><code>MessageProducer.Options</code></a> when creating a
 <a href="../../../io/atomix/group/messaging/MessageProducer.html" title="interface in io.atomix.group.messaging"><code>MessageProducer</code></a>.
 <pre>
   <code>
   MessageProducer.Options options = new MessageProducer.Options()
     .withExecution(MessageProducer.Execution.SYNC);
   MessageProducer&lt;String&gt; producer = member.messaging().producer("bar", options);
   </code>
 </pre>
 Producers can be configured to send messages using three execution policies:
 <ul>
   <li><a href="../../../io/atomix/group/messaging/MessageProducer.Execution.html#SYNC"><code>SYNC</code></a> sends messages to consumers
   and awaits acknowledgement from the consumer side of the queue. If a producer is producing to an entire group,
   synchronous producers will await acknowledgement from all members of the group.</li>
   <li><a href="../../../io/atomix/group/messaging/MessageProducer.Execution.html#ASYNC"><code>ASYNC</code></a> awaits acknowledgement of
   persistence in the cluster but not acknowledgement that messages have been received and processed by consumers.</li>
   <li><a href="../../../io/atomix/group/messaging/MessageProducer.Execution.html#REQUEST_REPLY"><code>REQUEST_REPLY</code></a> awaits
   arbitrary responses from all consumers to which a message is sent. If a message is sent to a group of consumers,
   message reply futures will be completed with a list of reply values.</li>
 </ul>
 When the <a href="../../../io/atomix/group/messaging/MessageProducer.html" title="interface in io.atomix.group.messaging"><code>MessageProducer</code></a> is configured with the
 <a href="../../../io/atomix/group/messaging/MessageProducer.Execution.html#ASYNC"><code>ASYNC</code></a> execution policy, the <a href="http://docs.oracle.com/javase/8/docs/api/java/util/concurrent/CompletableFuture.html?is-external=true" title="class or interface in java.util.concurrent"><code>CompletableFuture</code></a>
 returned by the <a href="../../../io/atomix/group/messaging/MessageProducer.html#send-T-"><code>MessageProducer.send(Object)</code></a> method will be completed as soon as
 the message is persisted in the cluster.
 <h3>Broadcast messaging</h3>
 Groups also provide a group-wide <a href="../../../io/atomix/group/messaging/MessageClient.html" title="interface in io.atomix.group.messaging"><code>MessageClient</code></a> that allows users to broadcast messages to all members of a
 group or send a direct message to a random member of a group. To use the group-wide message client, use the
 <a href="../../../io/atomix/group/DistributedGroup.html#messaging--"><code>messaging()</code></a> getter.
 <pre>
   <code>
   MessageProducer&lt;String&gt; producer = group.messaging().producer("foo");
   producer.send("Hello world!").thenRun(() -&gt; {
     // Message delivered to all group members
   });
   </code>
 </pre>
 By default, messages sent through the group-wide message producer will be sent to <em>all</em> members of the group.
 But just as <a href="../../../io/atomix/group/messaging/MessageProducer.Execution.html" title="enum in io.atomix.group.messaging"><code>Execution</code></a> policies can be used to define the
 criteria by which message operations are completed, the <a href="../../../io/atomix/group/messaging/MessageProducer.Delivery.html" title="enum in io.atomix.group.messaging"><code>Delivery</code></a>
 policy can be used to define how messages are delivered when using a group-wide producer.
 <pre>
   <code>
   MessageProducer.Options options = new MessageProducer.Options()
     .withDelivery(MessageProducer.Delivery.RANDOM);
   MessageProducer&lt;String&gt; producer = member.messaging().producer("bar", options);
   </code>
 </pre>
 Group-wide producers can be configured with the following <a href="../../../io/atomix/group/messaging/MessageProducer.Delivery.html" title="enum in io.atomix.group.messaging"><code>Delivery</code></a>
 policies:
 <ul>
   <li><a href="../../../io/atomix/group/messaging/MessageProducer.Delivery.html#RANDOM"><code>MessageProducer.Delivery.RANDOM</code></a> producers send each message to a random
   member of the group. In the event that a message is not successfully <a href="../../../io/atomix/group/messaging/Message.html#ack--"><code>acknowledged</code></a> by a
   member and that member fails or leaves the group, random messages will be redelivered to remaining members
   of the group.</li>
   <li><a href="../../../io/atomix/group/messaging/MessageProducer.Delivery.html#BROADCAST"><code>MessageProducer.Delivery.BROADCAST</code></a> producers send messages to all available
   members of a group. This option applies only to producers constructed from <a href="../../../io/atomix/group/DistributedGroup.html" title="interface in io.atomix.group"><code>DistributedGroup</code></a>
   messaging clients.</li>
 </ul>
 Delivery policies work in tandem with <a href="../../../io/atomix/group/messaging/MessageProducer.Execution.html" title="enum in io.atomix.group.messaging"><code>Execution</code></a> policies
 described above. For example, a group-wide producer configured with the
 <a href="../../../io/atomix/group/messaging/MessageProducer.Execution.html#REQUEST_REPLY"><code>REQUEST_REPLY</code></a> execution policy and
 the <a href="../../../io/atomix/group/messaging/MessageProducer.Delivery.html#BROADCAST"><code>BROADCAST</code></a> delivery policy will send each
 message to all members of the group and aggregate replies into a <a href="http://docs.oracle.com/javase/8/docs/api/java/util/Collection.html?is-external=true" title="class or interface in java.util"><code>Collection</code></a> once all consumers have replied
 to the message.
 <p>
 <h3>Message consumers</h3>
 Messages delivered to a group member must be received by listeners registered on the <a href="../../../io/atomix/group/LocalMember.html" title="interface in io.atomix.group"><code>LocalMember</code></a>'s
 <a href="../../../io/atomix/group/messaging/MessageService.html" title="interface in io.atomix.group.messaging"><code>MessageService</code></a>. Only the node to which a member belongs can listen for messages sent to that member. Thus,
 to listen for messages, join a group and create a <a href="../../../io/atomix/group/messaging/MessageConsumer.html" title="interface in io.atomix.group.messaging"><code>MessageConsumer</code></a>.
 <pre>
   <code>
   LocalMember localMember = group.join().join();
   MessageConsumer&lt;String&gt; consumer = localMember.messaging().consumer("foo");
   consumer.onMessage(message -&gt; {
     message.ack();
   });
   </code>
 </pre>
 When a message is received, consumers must always <a href="../../../io/atomix/group/messaging/Message.html#ack--"><code>Message.ack()</code></a> or <a href="../../../io/atomix/group/messaging/Message.html#reply-java.lang.Object-"><code>Message.reply(Object)</code></a> to the message.
 Failure to ack or reply to a message will result in a memory leak in the cluster and failure to deliver any additional
 messages to the consumer. When a consumer acknowledges a message, the message will be removed from memory in the cluster
 and the producer that sent the message will be notified according to its configuration.
 <h3>Persistent messaging</h3>
 Messages sent directly to specific members of a group are typically delivered only while that member is connected to
 the group. In the event that a member to which a message is sent fails, the message is failed. This can result in
 transparent failures when using the <a href="../../../io/atomix/group/messaging/MessageProducer.Execution.html#ASYNC"><code>ASYNC</code></a> execution
 policy. A message can be persisted but may never actually be delivered and acknowledged. To ensure that direct messages
 are eventually delivered, persistent members must be used.
 <pre>
   <code>
   LocalMember member = group.join("member-1").join();
   MessageConsumer&lt;String&gt; consumer = member.messaging().consumer("foo");
   consumer.onMessage(message -&gt; {
     ...
   });
   </code>
 </pre>
 When a message is sent to a persistent member, the message will be persisted in the cluster until it can be delivered
 to that member regardless of whether the member is actively connected to the cluster. If the persistent member crashes,
 once the member rejoins the group pending messages will be delivered. Persistent members are also free to switch nodes
 to rejoin the group on live nodes, and pending messages will still be redelivered.
 <p>
 Users must take care, however, when using persistent members. <a href="../../../io/atomix/group/messaging/MessageProducer.Delivery.html#BROADCAST"><code>BROADCAST</code></a>
 messages sent to groups with persistent members that are not connected to the cluster will be persisted in memory in the
 cluster until they can be delivered. If the producer that broadcasts the message is configured to await acknowledgement
 or replies from members, producer <a href="../../../io/atomix/group/messaging/MessageProducer.html#send-T-"><code>send</code></a> operations cannot
 be completed until dead members rejoin the group.
 <h3>Serialization</h3>
 Users are responsible for ensuring the serializability of tasks, messages, and properties set on the group
 and members of the group. Serialization is controlled by the group's <a href="http://atomix.io/catalyst/api/latest/io/atomix/catalyst/serializer/Serializer.html?is-external=true" title="class or interface in io.atomix.catalyst.serializer"><code>Serializer</code></a>
 which can be access via <a href="../../../io/atomix/resource/Resource.html#serializer--"><code>Resource.serializer()</code></a> or on the parent <code>Atomix</code> instance. Because objects are
 typically replicated throughout the cluster, <em>it's critical that any object sent from any node should be
 serializable by all other nodes</em>.
 <p>
 Users should register serializable types before performing any operations on the group.
 <pre>
   <code>
   DistributedGroup group = atomix.getGroup("group").get();
   group.serializer().register(User.class, UserSerializer.class);
   </code>
 </pre>
 For the best performance from serialization, it is recommended that serializable types be registered with
 unique type IDs. This allows the Catalyst <a href="http://atomix.io/catalyst/api/latest/io/atomix/catalyst/serializer/Serializer.html?is-external=true" title="class or interface in io.atomix.catalyst.serializer"><code>Serializer</code></a> to identify the
 type by its serialization ID rather than its class name. It's essential that the ID for a given type is
 the same all all nodes in the cluster.
 <pre>
   <code>
   group.serializer().register(User.class, 1, UserSerializer.class);
   </code>
 </pre>
 Users can also serialize <a href="http://docs.oracle.com/javase/8/docs/api/java/io/Serializable.html?is-external=true" title="class or interface in java.io"><code>Serializable</code></a> types by simply registering the class without any
 other serializer. Catalyst will attempt to use the optimal serializer based on the interfaces implemented
 by the class. Alternatively, type registration can be disabled altogether via <a href="http://atomix.io/catalyst/api/latest/io/atomix/catalyst/serializer/Serializer.html?is-external=true#disableWhitelist--" title="class or interface in io.atomix.catalyst.serializer"><code>Serializer.disableWhitelist()</code></a>,
 however this is not recommended as arbitrary deserialization of class names is slow and is a security risk.
 <h3>Implementation</h3>
 Group state is managed in a Copycat replicated <a href="http://atomix.io/copycat/api/latest/io/atomix/copycat/server/StateMachine.html?is-external=true" title="class or interface in io.atomix.copycat.server"><code>StateMachine</code></a>. When a
 <code>DistributedGroup</code> is created, an instance of the group state machine is created on each replica in
 the cluster. The state machine instance manages state for the specific membership group. When a member
 <a href="../../../io/atomix/group/DistributedGroup.html#join--"><code>joins</code></a> the group, a join request is sent to the cluster and logged and replicated before
 being applied to the group state machine. Once the join request has been committed and applied to the
 state machine, the group state is updated and existing group members are notified by
 <a href="http://atomix.io/copycat/api/latest/io/atomix/copycat/server/session/ServerSession.html?is-external=true#publish-java.lang.String-java.lang.Object-" title="class or interface in io.atomix.copycat.server.session"><code>publishing</code></a> state change
 notifications to open instances of the group. Membership change event notifications are received by all
 open instances of the resource.
 <p>
 Leader election is performed by the group state machine. When the first member joins the group, that
 member will automatically be assigned as the group member. Each time an additional member joins the group,
 the new member will be placed in a leader queue. In the event that the current group leader's
 <a href="http://atomix.io/copycat/api/latest/io/atomix/copycat/session/Session.html?is-external=true" title="class or interface in io.atomix.copycat.session"><code>Session</code></a> expires or is closed, the group state machine will assign a new
 leader by pulling from the leader queue and will publish an <code>elect</code> event to all remaining group
 members. Additionally, for each new leader of the group, the state machine will publish a <code>term</code> change
 event, providing a globally unique, monotonically increasing token uniquely associated with the new leader.
 <p>
 To track group membership, the group state machine tracks the state of the <a href="http://atomix.io/copycat/api/latest/io/atomix/copycat/session/Session.html?is-external=true" title="class or interface in io.atomix.copycat.session"><code>Session</code></a>
 associated with each open instance of the group. In the event that the session expires or is closed, the group
 member associated with that session will automatically be removed from the group and remaining instances
 of the group will be notified.
 <p>
 The group state machine facilitates direct and broadcast messaging through writes to the Atomix cluster. Each message
 sent to a group or a member of a group is committed as a single write to the cluster. Once persisted in the cluster,
 messages are delivered to clients through the state machine's session events API. The group state machine delivers
 messages to sessions based on the configured per-message delivery policy, and client-side group instances are responsible
 for dispatching received messages to the appropriate consumers. When a consumer acknowledges or replies to a message,
 another write is commited to the Atomix cluster, and the group state machine completes the associated message.
 <p>
 The group state machine manages compaction of the replicated log by tracking which state changes contribute to
 the state of the group at any given time. For instance, when a member joins the group, the commit that added the
 member to the group contributes to the group's state as long as the member remains a part of the group. Once the
 member leaves the group or its session is expired, the commit that created and remove the member no longer contribute
 to the group's state and are therefore released from the state machine and will be removed from the log during
 compaction.</div>
<dl>
<dt><span class="simpleTagLabel">Author:</span></dt>
<dd><a href="http://github.com/kuujo>Jordan Halterman</a></dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../io/atomix/group/GroupMember.html" title="interface in io.atomix.group"><code>GroupMember</code></a></dd>
</dl>
</li>
</ul>
</div>
<div class="summary">
<ul class="blockList">
<li class="blockList">
<!-- ======== NESTED CLASS SUMMARY ======== -->
<ul class="blockList">
<li class="blockList"><a name="nested.class.summary">
<!--   -->
</a>
<h3>Nested Class Summary</h3>
<table class="memberSummary" border="0" cellpadding="3" cellspacing="0" summary="Nested Class Summary table, listing nested classes, and an explanation">
<caption><span>Nested Classes</span><span class="tabEnd">&nbsp;</span></caption>
<tr>
<th class="colFirst" scope="col">Modifier and Type</th>
<th class="colLast" scope="col">Interface and Description</th>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static class&nbsp;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../io/atomix/group/DistributedGroup.Config.html" title="class in io.atomix.group">DistributedGroup.Config</a></span></code>
<div class="block">Configuration for cluster-wide <a href="../../../io/atomix/group/DistributedGroup.html" title="interface in io.atomix.group"><code>DistributedGroup</code></a>s.</div>
</td>
</tr>
</table>
<ul class="blockList">
<li class="blockList"><a name="nested.classes.inherited.from.class.io.atomix.resource.Resource">
<!--   -->
</a>
<h3>Nested classes/interfaces inherited from interface&nbsp;io.atomix.resource.<a href="../../../io/atomix/resource/Resource.html" title="interface in io.atomix.resource">Resource</a></h3>
<code><a href="../../../io/atomix/resource/Resource.Options.html" title="class in io.atomix.resource">Resource.Options</a>, <a href="../../../io/atomix/resource/Resource.State.html" title="enum in io.atomix.resource">Resource.State</a></code></li>
</ul>
</li>
</ul>
<!-- ========== METHOD SUMMARY =========== -->
<ul class="blockList">
<li class="blockList"><a name="method.summary">
<!--   -->
</a>
<h3>Method Summary</h3>
<table class="memberSummary" border="0" cellpadding="3" cellspacing="0" summary="Method Summary table, listing methods, and an explanation">
<caption><span id="t0" class="activeTableTab"><span>All Methods</span><span class="tabEnd">&nbsp;</span></span><span id="t2" class="tableTab"><span><a href="javascript:show(2);">Instance Methods</a></span><span class="tabEnd">&nbsp;</span></span><span id="t3" class="tableTab"><span><a href="javascript:show(4);">Abstract Methods</a></span><span class="tabEnd">&nbsp;</span></span></caption>
<tr>
<th class="colFirst" scope="col">Modifier and Type</th>
<th class="colLast" scope="col">Method and Description</th>
</tr>
<tr id="i0" class="altColor">
<td class="colFirst"><code><a href="../../../io/atomix/group/election/Election.html" title="interface in io.atomix.group.election">Election</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../io/atomix/group/DistributedGroup.html#election--">election</a></span>()</code>
<div class="block">Returns the group election.</div>
</td>
</tr>
<tr id="i1" class="rowColor">
<td class="colFirst"><code><a href="http://docs.oracle.com/javase/8/docs/api/java/util/concurrent/CompletableFuture.html?is-external=true" title="class or interface in java.util.concurrent">CompletableFuture</a>&lt;<a href="../../../io/atomix/group/LocalMember.html" title="interface in io.atomix.group">LocalMember</a>&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../io/atomix/group/DistributedGroup.html#join--">join</a></span>()</code>
<div class="block">Joins the instance to the membership group.</div>
</td>
</tr>
<tr id="i2" class="altColor">
<td class="colFirst"><code><a href="http://docs.oracle.com/javase/8/docs/api/java/util/concurrent/CompletableFuture.html?is-external=true" title="class or interface in java.util.concurrent">CompletableFuture</a>&lt;<a href="../../../io/atomix/group/LocalMember.html" title="interface in io.atomix.group">LocalMember</a>&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../io/atomix/group/DistributedGroup.html#join-java.lang.Object-">join</a></span>(<a href="http://docs.oracle.com/javase/8/docs/api/java/lang/Object.html?is-external=true" title="class or interface in java.lang">Object</a>&nbsp;metadata)</code>
<div class="block">Joins the instance to the membership group with a user-provided member ID.</div>
</td>
</tr>
<tr id="i3" class="rowColor">
<td class="colFirst"><code><a href="http://docs.oracle.com/javase/8/docs/api/java/util/concurrent/CompletableFuture.html?is-external=true" title="class or interface in java.util.concurrent">CompletableFuture</a>&lt;<a href="../../../io/atomix/group/LocalMember.html" title="interface in io.atomix.group">LocalMember</a>&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../io/atomix/group/DistributedGroup.html#join-java.lang.String-">join</a></span>(<a href="http://docs.oracle.com/javase/8/docs/api/java/lang/String.html?is-external=true" title="class or interface in java.lang">String</a>&nbsp;memberId)</code>
<div class="block">Joins the instance to the membership group with a user-provided member ID.</div>
</td>
</tr>
<tr id="i4" class="altColor">
<td class="colFirst"><code><a href="http://docs.oracle.com/javase/8/docs/api/java/util/concurrent/CompletableFuture.html?is-external=true" title="class or interface in java.util.concurrent">CompletableFuture</a>&lt;<a href="../../../io/atomix/group/LocalMember.html" title="interface in io.atomix.group">LocalMember</a>&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../io/atomix/group/DistributedGroup.html#join-java.lang.String-java.lang.Object-">join</a></span>(<a href="http://docs.oracle.com/javase/8/docs/api/java/lang/String.html?is-external=true" title="class or interface in java.lang">String</a>&nbsp;memberId,
    <a href="http://docs.oracle.com/javase/8/docs/api/java/lang/Object.html?is-external=true" title="class or interface in java.lang">Object</a>&nbsp;metadata)</code>
<div class="block">Joins the instance to the membership group with a user-provided member ID.</div>
</td>
</tr>
<tr id="i5" class="rowColor">
<td class="colFirst"><code><a href="../../../io/atomix/group/GroupMember.html" title="interface in io.atomix.group">GroupMember</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../io/atomix/group/DistributedGroup.html#member-java.lang.String-">member</a></span>(<a href="http://docs.oracle.com/javase/8/docs/api/java/lang/String.html?is-external=true" title="class or interface in java.lang">String</a>&nbsp;memberId)</code>
<div class="block">Gets a group member by ID.</div>
</td>
</tr>
<tr id="i6" class="altColor">
<td class="colFirst"><code><a href="http://docs.oracle.com/javase/8/docs/api/java/util/Collection.html?is-external=true" title="class or interface in java.util">Collection</a>&lt;<a href="../../../io/atomix/group/GroupMember.html" title="interface in io.atomix.group">GroupMember</a>&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../io/atomix/group/DistributedGroup.html#members--">members</a></span>()</code>
<div class="block">Gets the collection of all members in the group.</div>
</td>
</tr>
<tr id="i7" class="rowColor">
<td class="colFirst"><code><a href="../../../io/atomix/group/messaging/MessageClient.html" title="interface in io.atomix.group.messaging">MessageClient</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../io/atomix/group/DistributedGroup.html#messaging--">messaging</a></span>()</code>
<div class="block">Returns the group message client.</div>
</td>
</tr>
<tr id="i8" class="altColor">
<td class="colFirst"><code><a href="http://atomix.io/catalyst/api/latest/io/atomix/catalyst/util/Listener.html?is-external=true" title="class or interface in io.atomix.catalyst.util">Listener</a>&lt;<a href="../../../io/atomix/group/GroupMember.html" title="interface in io.atomix.group">GroupMember</a>&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../io/atomix/group/DistributedGroup.html#onJoin-java.util.function.Consumer-">onJoin</a></span>(<a href="http://docs.oracle.com/javase/8/docs/api/java/util/function/Consumer.html?is-external=true" title="class or interface in java.util.function">Consumer</a>&lt;<a href="../../../io/atomix/group/GroupMember.html" title="interface in io.atomix.group">GroupMember</a>&gt;&nbsp;listener)</code>
<div class="block">Adds a listener for members joining the group.</div>
</td>
</tr>
<tr id="i9" class="rowColor">
<td class="colFirst"><code><a href="http://atomix.io/catalyst/api/latest/io/atomix/catalyst/util/Listener.html?is-external=true" title="class or interface in io.atomix.catalyst.util">Listener</a>&lt;<a href="../../../io/atomix/group/GroupMember.html" title="interface in io.atomix.group">GroupMember</a>&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../io/atomix/group/DistributedGroup.html#onLeave-java.util.function.Consumer-">onLeave</a></span>(<a href="http://docs.oracle.com/javase/8/docs/api/java/util/function/Consumer.html?is-external=true" title="class or interface in java.util.function">Consumer</a>&lt;<a href="../../../io/atomix/group/GroupMember.html" title="interface in io.atomix.group">GroupMember</a>&gt;&nbsp;listener)</code>
<div class="block">Adds a listener for members leaving the group.</div>
</td>
</tr>
<tr id="i10" class="altColor">
<td class="colFirst"><code><a href="http://docs.oracle.com/javase/8/docs/api/java/util/concurrent/CompletableFuture.html?is-external=true" title="class or interface in java.util.concurrent">CompletableFuture</a>&lt;<a href="http://docs.oracle.com/javase/8/docs/api/java/lang/Void.html?is-external=true" title="class or interface in java.lang">Void</a>&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../io/atomix/group/DistributedGroup.html#remove-java.lang.String-">remove</a></span>(<a href="http://docs.oracle.com/javase/8/docs/api/java/lang/String.html?is-external=true" title="class or interface in java.lang">String</a>&nbsp;memberId)</code>
<div class="block">Removes the member with the given member ID from the group.</div>
</td>
</tr>
</table>
<ul class="blockList">
<li class="blockList"><a name="methods.inherited.from.class.io.atomix.resource.Resource">
<!--   -->
</a>
<h3>Methods inherited from interface&nbsp;io.atomix.resource.<a href="../../../io/atomix/resource/Resource.html" title="interface in io.atomix.resource">Resource</a></h3>
<code><a href="../../../io/atomix/resource/Resource.html#close--">close</a>, <a href="../../../io/atomix/resource/Resource.html#config--">config</a>, <a href="../../../io/atomix/resource/Resource.html#context--">context</a>, <a href="../../../io/atomix/resource/Resource.html#delete--">delete</a>, <a href="../../../io/atomix/resource/Resource.html#onStateChange-java.util.function.Consumer-">onStateChange</a>, <a href="../../../io/atomix/resource/Resource.html#open--">open</a>, <a href="../../../io/atomix/resource/Resource.html#options--">options</a>, <a href="../../../io/atomix/resource/Resource.html#serializer--">serializer</a>, <a href="../../../io/atomix/resource/Resource.html#state--">state</a>, <a href="../../../io/atomix/resource/Resource.html#type--">type</a></code></li>
</ul>
<ul class="blockList">
<li class="blockList"><a name="methods.inherited.from.class.io.atomix.catalyst.util.Managed">
<!--   -->
</a>
<h3>Methods inherited from interface&nbsp;io.atomix.catalyst.util.<a href="http://atomix.io/catalyst/api/latest/io/atomix/catalyst/util/Managed.html?is-external=true" title="class or interface in io.atomix.catalyst.util">Managed</a></h3>
<code><a href="http://atomix.io/catalyst/api/latest/io/atomix/catalyst/util/Managed.html?is-external=true#isClosed--" title="class or interface in io.atomix.catalyst.util">isClosed</a>, <a href="http://atomix.io/catalyst/api/latest/io/atomix/catalyst/util/Managed.html?is-external=true#isOpen--" title="class or interface in io.atomix.catalyst.util">isOpen</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
<div class="details">
<ul class="blockList">
<li class="blockList">
<!-- ============ METHOD DETAIL ========== -->
<ul class="blockList">
<li class="blockList"><a name="method.detail">
<!--   -->
</a>
<h3>Method Detail</h3>
<a name="election--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>election</h4>
<pre><a href="../../../io/atomix/group/election/Election.html" title="interface in io.atomix.group.election">Election</a>&nbsp;election()</pre>
<div class="block">Returns the group election.
 <p>
 The returned election is specific to this group's set of members. The <a href="../../../io/atomix/group/election/Term.html" title="interface in io.atomix.group.election"><code>Term</code></a> defined by the returned
 election will not necessarily be reflected in any subgroups of this group.</div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The group election.</dd>
</dl>
</li>
</ul>
<a name="messaging--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>messaging</h4>
<pre><a href="../../../io/atomix/group/messaging/MessageClient.html" title="interface in io.atomix.group.messaging">MessageClient</a>&nbsp;messaging()</pre>
<div class="block">Returns the group message client.
 <p>
 The returned message client is group-wide and can be used to broadcast messages to all members of the group
 or to random members of the group.</div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The group message client.</dd>
</dl>
</li>
</ul>
<a name="member-java.lang.String-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>member</h4>
<pre><a href="../../../io/atomix/group/GroupMember.html" title="interface in io.atomix.group">GroupMember</a>&nbsp;member(<a href="http://docs.oracle.com/javase/8/docs/api/java/lang/String.html?is-external=true" title="class or interface in java.lang">String</a>&nbsp;memberId)</pre>
<div class="block">Gets a group member by ID.
 <p>
 If the member with the given ID has not <a href="../../../io/atomix/group/DistributedGroup.html#join--"><code>joined</code></a> the membership group, the resulting
 <a href="../../../io/atomix/group/GroupMember.html" title="interface in io.atomix.group"><code>GroupMember</code></a> will be <code>null</code>.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>memberId</code> - The member ID for which to return a <a href="../../../io/atomix/group/GroupMember.html" title="interface in io.atomix.group"><code>GroupMember</code></a>.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The member with the given <code>memberId</code> or <code>null</code> if it is not a known member of the group.</dd>
</dl>
</li>
</ul>
<a name="members--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>members</h4>
<pre><a href="http://docs.oracle.com/javase/8/docs/api/java/util/Collection.html?is-external=true" title="class or interface in java.util">Collection</a>&lt;<a href="../../../io/atomix/group/GroupMember.html" title="interface in io.atomix.group">GroupMember</a>&gt;&nbsp;members()</pre>
<div class="block">Gets the collection of all members in the group.
 <p>
 The group members are fetched from the cluster. If any <a href="../../../io/atomix/group/GroupMember.html" title="interface in io.atomix.group"><code>GroupMember</code></a> instances have been referenced
 by this membership group instance, the same object will be returned for that member.
 <p>
 This method returns a <a href="http://docs.oracle.com/javase/8/docs/api/java/util/concurrent/CompletableFuture.html?is-external=true" title="class or interface in java.util.concurrent"><code>CompletableFuture</code></a> which can be used to block until the operation completes
 or to be notified in a separate thread once the operation completes. To block until the operation completes,
 use the <a href="http://docs.oracle.com/javase/8/docs/api/java/util/concurrent/CompletableFuture.html?is-external=true#join--" title="class or interface in java.util.concurrent"><code>CompletableFuture.join()</code></a> method to block the calling thread:
 <pre>
   <code>
   Collection&lt;GroupMember&gt; members = group.members().get();
   </code>
 </pre>
 Alternatively, to execute the operation asynchronous and be notified once the lock is acquired in a different
 thread, use one of the many completable future callbacks:
 <pre>
   <code>
   group.members().thenAccept(members -&gt; {
     members.forEach(member -&gt; {
       member.send("test", "Hello world!");
     });
   });
   </code>
 </pre></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The collection of all members in the group.</dd>
</dl>
</li>
</ul>
<a name="join--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>join</h4>
<pre><a href="http://docs.oracle.com/javase/8/docs/api/java/util/concurrent/CompletableFuture.html?is-external=true" title="class or interface in java.util.concurrent">CompletableFuture</a>&lt;<a href="../../../io/atomix/group/LocalMember.html" title="interface in io.atomix.group">LocalMember</a>&gt;&nbsp;join()</pre>
<div class="block">Joins the instance to the membership group.
 <p>
 Joining the group results in a <em>new</em> member being created and joining the group. Each <a href="../../../io/atomix/group/DistributedGroup.html" title="interface in io.atomix.group"><code>DistributedGroup</code></a>
 instance may represent multiple members of a group. The returned <a href="http://docs.oracle.com/javase/8/docs/api/java/util/concurrent/CompletableFuture.html?is-external=true" title="class or interface in java.util.concurrent"><code>CompletableFuture</code></a> will be completed
 with the joined <a href="../../../io/atomix/group/LocalMember.html" title="interface in io.atomix.group"><code>LocalMember</code></a> object once the member has joined the group, but does not guarantee that
 all other instances of the group have seen the newly joined member.
 <p>
 This method returns a <a href="http://docs.oracle.com/javase/8/docs/api/java/util/concurrent/CompletableFuture.html?is-external=true" title="class or interface in java.util.concurrent"><code>CompletableFuture</code></a> which can be used to block until the operation completes
 or to be notified in a separate thread once the operation completes. To block until the operation completes,
 use the <a href="http://docs.oracle.com/javase/8/docs/api/java/util/concurrent/CompletableFuture.html?is-external=true#join--" title="class or interface in java.util.concurrent"><code>CompletableFuture.join()</code></a> method to block the calling thread:
 <pre>
   <code>
   group.join().join();
   </code>
 </pre>
 Alternatively, to execute the operation asynchronous and be notified once the lock is acquired in a different
 thread, use one of the many completable future callbacks:
 <pre>
   <code>
   group.join().thenAccept(thisMember -&gt; System.out.println("This member is: " + thisMember.id()));
   </code>
 </pre></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>A completable future to be completed once the member has joined.</dd>
</dl>
</li>
</ul>
<a name="join-java.lang.String-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>join</h4>
<pre><a href="http://docs.oracle.com/javase/8/docs/api/java/util/concurrent/CompletableFuture.html?is-external=true" title="class or interface in java.util.concurrent">CompletableFuture</a>&lt;<a href="../../../io/atomix/group/LocalMember.html" title="interface in io.atomix.group">LocalMember</a>&gt;&nbsp;join(<a href="http://docs.oracle.com/javase/8/docs/api/java/lang/String.html?is-external=true" title="class or interface in java.lang">String</a>&nbsp;memberId)</pre>
<div class="block">Joins the instance to the membership group with a user-provided member ID.
 <p>
 Joining the group results in a <em>new</em> member being created and joining the group. Each <a href="../../../io/atomix/group/DistributedGroup.html" title="interface in io.atomix.group"><code>DistributedGroup</code></a>
 instance may represent multiple members of a group. The returned <a href="http://docs.oracle.com/javase/8/docs/api/java/util/concurrent/CompletableFuture.html?is-external=true" title="class or interface in java.util.concurrent"><code>CompletableFuture</code></a> will be completed
 with the joined <a href="../../../io/atomix/group/LocalMember.html" title="interface in io.atomix.group"><code>LocalMember</code></a> object once the member has joined the group, but does not guarantee that
 all other instances of the group have seen the newly joined member.
 <p>
 When joining a group with a user-provided <code>memberId</code>, a persistent member is created. In the event that this
 node crashes, the member may rejoin the group on any node with the same <code>memberId</code> and receive pending messages.
 While the persistent member is disconnected from the cluster, it will not appear in the group <a href="../../../io/atomix/group/DistributedGroup.html#members--"><code>members()</code></a>
 list but its state will not be removed from the cluster.
 <p>
 This method returns a <a href="http://docs.oracle.com/javase/8/docs/api/java/util/concurrent/CompletableFuture.html?is-external=true" title="class or interface in java.util.concurrent"><code>CompletableFuture</code></a> which can be used to block until the operation completes
 or to be notified in a separate thread once the operation completes. To block until the operation completes,
 use the <a href="http://docs.oracle.com/javase/8/docs/api/java/util/concurrent/CompletableFuture.html?is-external=true#join--" title="class or interface in java.util.concurrent"><code>CompletableFuture.join()</code></a> method to block the calling thread:
 <pre>
   <code>
   group.join("foo").join();
   </code>
 </pre>
 Alternatively, to execute the operation asynchronous and be notified once the lock is acquired in a different
 thread, use one of the many completable future callbacks:
 <pre>
   <code>
   group.join("foo").thenAccept(thisMember -&gt; System.out.println("This member is: " + thisMember.id()));
   </code>
 </pre></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>memberId</code> - The unique member ID to assign to the member.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>A completable future to be completed once the member has joined.</dd>
</dl>
</li>
</ul>
<a name="join-java.lang.Object-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>join</h4>
<pre><a href="http://docs.oracle.com/javase/8/docs/api/java/util/concurrent/CompletableFuture.html?is-external=true" title="class or interface in java.util.concurrent">CompletableFuture</a>&lt;<a href="../../../io/atomix/group/LocalMember.html" title="interface in io.atomix.group">LocalMember</a>&gt;&nbsp;join(<a href="http://docs.oracle.com/javase/8/docs/api/java/lang/Object.html?is-external=true" title="class or interface in java.lang">Object</a>&nbsp;metadata)</pre>
<div class="block">Joins the instance to the membership group with a user-provided member ID.
 <p>
 Joining the group results in a <em>new</em> member being created and joining the group. Each <a href="../../../io/atomix/group/DistributedGroup.html" title="interface in io.atomix.group"><code>DistributedGroup</code></a>
 instance may represent multiple members of a group. The returned <a href="http://docs.oracle.com/javase/8/docs/api/java/util/concurrent/CompletableFuture.html?is-external=true" title="class or interface in java.util.concurrent"><code>CompletableFuture</code></a> will be completed
 with the joined <a href="../../../io/atomix/group/LocalMember.html" title="interface in io.atomix.group"><code>LocalMember</code></a> object once the member has joined the group, but does not guarantee that
 all other instances of the group have seen the newly joined member.
 <p>
 <code>metadata</code> provided when a persistent member joins a group can be viewed by all other instances of the
 same group. Metadata objects mut be serializable either via Java's <a href="http://docs.oracle.com/javase/8/docs/api/java/io/Serializable.html?is-external=true" title="class or interface in java.io"><code>Serializable</code></a> or by registering a
 Catalyst <a href="http://atomix.io/catalyst/api/latest/io/atomix/catalyst/serializer/TypeSerializer.html?is-external=true" title="class or interface in io.atomix.catalyst.serializer"><code>TypeSerializer</code></a> on the group's <a href="../../../io/atomix/resource/Resource.html#serializer--"><code>Resource.serializer()</code></a>.
 <p>
 This method returns a <a href="http://docs.oracle.com/javase/8/docs/api/java/util/concurrent/CompletableFuture.html?is-external=true" title="class or interface in java.util.concurrent"><code>CompletableFuture</code></a> which can be used to block until the operation completes
 or to be notified in a separate thread once the operation completes. To block until the operation completes,
 use the <a href="http://docs.oracle.com/javase/8/docs/api/java/util/concurrent/CompletableFuture.html?is-external=true#join--" title="class or interface in java.util.concurrent"><code>CompletableFuture.join()</code></a> method to block the calling thread:
 <pre>
   <code>
   group.join("foo").join();
   </code>
 </pre>
 Alternatively, to execute the operation asynchronous and be notified once the lock is acquired in a different
 thread, use one of the many completable future callbacks:
 <pre>
   <code>
   group.join("foo").thenAccept(thisMember -&gt; System.out.println("This member is: " + thisMember.id()));
   </code>
 </pre></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>metadata</code> - Metadata to assign to the joined group member.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>A completable future to be completed once the member has joined.</dd>
</dl>
</li>
</ul>
<a name="join-java.lang.String-java.lang.Object-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>join</h4>
<pre><a href="http://docs.oracle.com/javase/8/docs/api/java/util/concurrent/CompletableFuture.html?is-external=true" title="class or interface in java.util.concurrent">CompletableFuture</a>&lt;<a href="../../../io/atomix/group/LocalMember.html" title="interface in io.atomix.group">LocalMember</a>&gt;&nbsp;join(<a href="http://docs.oracle.com/javase/8/docs/api/java/lang/String.html?is-external=true" title="class or interface in java.lang">String</a>&nbsp;memberId,
                                    <a href="http://docs.oracle.com/javase/8/docs/api/java/lang/Object.html?is-external=true" title="class or interface in java.lang">Object</a>&nbsp;metadata)</pre>
<div class="block">Joins the instance to the membership group with a user-provided member ID.
 <p>
 Joining the group results in a <em>new</em> member being created and joining the group. Each <a href="../../../io/atomix/group/DistributedGroup.html" title="interface in io.atomix.group"><code>DistributedGroup</code></a>
 instance may represent multiple members of a group. The returned <a href="http://docs.oracle.com/javase/8/docs/api/java/util/concurrent/CompletableFuture.html?is-external=true" title="class or interface in java.util.concurrent"><code>CompletableFuture</code></a> will be completed
 with the joined <a href="../../../io/atomix/group/LocalMember.html" title="interface in io.atomix.group"><code>LocalMember</code></a> object once the member has joined the group, but does not guarantee that
 all other instances of the group have seen the newly joined member.
 <p>
 When joining a group with a user-provided <code>memberId</code>, a persistent member is created. In the event that this
 node crashes, the member may rejoin the group on any node with the same <code>memberId</code> and receive pending messages.
 While the persistent member is disconnected from the cluster, it will not appear in the group <a href="../../../io/atomix/group/DistributedGroup.html#members--"><code>members()</code></a>
 list but its state will not be removed from the cluster.
 <p>
 <code>metadata</code> provided when a persistent member joins a group can be viewed by all other instances of the
 same group. Metadata objects mut be serializable either via Java's <a href="http://docs.oracle.com/javase/8/docs/api/java/io/Serializable.html?is-external=true" title="class or interface in java.io"><code>Serializable</code></a> or by registering a
 Catalyst <a href="http://atomix.io/catalyst/api/latest/io/atomix/catalyst/serializer/TypeSerializer.html?is-external=true" title="class or interface in io.atomix.catalyst.serializer"><code>TypeSerializer</code></a> on the group's <a href="../../../io/atomix/resource/Resource.html#serializer--"><code>Resource.serializer()</code></a>.
 <p>
 This method returns a <a href="http://docs.oracle.com/javase/8/docs/api/java/util/concurrent/CompletableFuture.html?is-external=true" title="class or interface in java.util.concurrent"><code>CompletableFuture</code></a> which can be used to block until the operation completes
 or to be notified in a separate thread once the operation completes. To block until the operation completes,
 use the <a href="http://docs.oracle.com/javase/8/docs/api/java/util/concurrent/CompletableFuture.html?is-external=true#join--" title="class or interface in java.util.concurrent"><code>CompletableFuture.join()</code></a> method to block the calling thread:
 <pre>
   <code>
   group.join("foo", new MyMetadata()).join();
   </code>
 </pre>
 Alternatively, to execute the operation asynchronous and be notified once the lock is acquired in a different
 thread, use one of the many completable future callbacks:
 <pre>
   <code>
   group.join("foo", new MyMetadata()).thenAccept(thisMember -&gt; System.out.println("This member is: " + thisMember.id()));
   </code>
 </pre></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>memberId</code> - The unique member ID to assign to the member.</dd>
<dd><code>metadata</code> - Metadata to assign to the joined group member.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>A completable future to be completed once the member has joined.</dd>
</dl>
</li>
</ul>
<a name="onJoin-java.util.function.Consumer-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>onJoin</h4>
<pre><a href="http://atomix.io/catalyst/api/latest/io/atomix/catalyst/util/Listener.html?is-external=true" title="class or interface in io.atomix.catalyst.util">Listener</a>&lt;<a href="../../../io/atomix/group/GroupMember.html" title="interface in io.atomix.group">GroupMember</a>&gt;&nbsp;onJoin(<a href="http://docs.oracle.com/javase/8/docs/api/java/util/function/Consumer.html?is-external=true" title="class or interface in java.util.function">Consumer</a>&lt;<a href="../../../io/atomix/group/GroupMember.html" title="interface in io.atomix.group">GroupMember</a>&gt;&nbsp;listener)</pre>
<div class="block">Adds a listener for members joining the group.
 <p>
 The provided <a href="http://docs.oracle.com/javase/8/docs/api/java/util/function/Consumer.html?is-external=true" title="class or interface in java.util.function"><code>Consumer</code></a> will be called each time a member joins the group. Note that
 the join consumer will be called before the joining member's <a href="../../../io/atomix/group/DistributedGroup.html#join--"><code>join()</code></a> completes.
 <p>
 The returned <a href="http://atomix.io/catalyst/api/latest/io/atomix/catalyst/util/Listener.html?is-external=true" title="class or interface in io.atomix.catalyst.util"><code>Listener</code></a> can be used to <a href="http://atomix.io/catalyst/api/latest/io/atomix/catalyst/util/Listener.html?is-external=true#close--" title="class or interface in io.atomix.catalyst.util"><code>unregister</code></a> the listener
 when its use if finished.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>listener</code> - The join listener.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The listener context.</dd>
</dl>
</li>
</ul>
<a name="remove-java.lang.String-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>remove</h4>
<pre><a href="http://docs.oracle.com/javase/8/docs/api/java/util/concurrent/CompletableFuture.html?is-external=true" title="class or interface in java.util.concurrent">CompletableFuture</a>&lt;<a href="http://docs.oracle.com/javase/8/docs/api/java/lang/Void.html?is-external=true" title="class or interface in java.lang">Void</a>&gt;&nbsp;remove(<a href="http://docs.oracle.com/javase/8/docs/api/java/lang/String.html?is-external=true" title="class or interface in java.lang">String</a>&nbsp;memberId)</pre>
<div class="block">Removes the member with the given member ID from the group.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>memberId</code> - The member ID of the member to remove from the group.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>A completable future to be completed once the member has been removed.</dd>
</dl>
</li>
</ul>
<a name="onLeave-java.util.function.Consumer-">
<!--   -->
</a>
<ul class="blockListLast">
<li class="blockList">
<h4>onLeave</h4>
<pre><a href="http://atomix.io/catalyst/api/latest/io/atomix/catalyst/util/Listener.html?is-external=true" title="class or interface in io.atomix.catalyst.util">Listener</a>&lt;<a href="../../../io/atomix/group/GroupMember.html" title="interface in io.atomix.group">GroupMember</a>&gt;&nbsp;onLeave(<a href="http://docs.oracle.com/javase/8/docs/api/java/util/function/Consumer.html?is-external=true" title="class or interface in java.util.function">Consumer</a>&lt;<a href="../../../io/atomix/group/GroupMember.html" title="interface in io.atomix.group">GroupMember</a>&gt;&nbsp;listener)</pre>
<div class="block">Adds a listener for members leaving the group.
 <p>
 The provided <a href="http://docs.oracle.com/javase/8/docs/api/java/util/function/Consumer.html?is-external=true" title="class or interface in java.util.function"><code>Consumer</code></a> will be called each time a member leaves the group. Members can
 leave the group either voluntarily or by crashing or otherwise becoming disconnected from the
 cluster for longer than their session timeout. Note that the leave consumer will be called before
 the leaving member's <a href="../../../io/atomix/group/LocalMember.html#leave--"><code>LocalMember.leave()</code></a> completes.
 <p>
 The returned <a href="http://atomix.io/catalyst/api/latest/io/atomix/catalyst/util/Listener.html?is-external=true" title="class or interface in io.atomix.catalyst.util"><code>Listener</code></a> can be used to <a href="http://atomix.io/catalyst/api/latest/io/atomix/catalyst/util/Listener.html?is-external=true#close--" title="class or interface in io.atomix.catalyst.util"><code>unregister</code></a> the listener
 when its use if finished.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>listener</code> - The leave listener.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The listener context.</dd>
</dl>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</div>
<!-- ========= END OF CLASS DATA ========= -->
<!-- ======= START OF BOTTOM NAVBAR ====== -->
<div class="bottomNav"><a name="navbar.bottom">
<!--   -->
</a>
<div class="skipNav"><a href="#skip.navbar.bottom" title="Skip navigation links">Skip navigation links</a></div>
<a name="navbar.bottom.firstrow">
<!--   -->
</a>
<ul class="navList" title="Navigation">
<li><a href="../../../overview-summary.html">Overview</a></li>
<li><a href="package-summary.html">Package</a></li>
<li class="navBarCell1Rev">Class</li>
<li><a href="class-use/DistributedGroup.html">Use</a></li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../../../deprecated-list.html">Deprecated</a></li>
<li><a href="../../../index-all.html">Index</a></li>
<li><a href="../../../help-doc.html">Help</a></li>
</ul>
</div>
<div class="subNav">
<ul class="navList">
<li>Prev&nbsp;Class</li>
<li><a href="../../../io/atomix/group/DistributedGroup.Config.html" title="class in io.atomix.group"><span class="typeNameLink">Next&nbsp;Class</span></a></li>
</ul>
<ul class="navList">
<li><a href="../../../index.html?io/atomix/group/DistributedGroup.html" target="_top">Frames</a></li>
<li><a href="DistributedGroup.html" target="_top">No&nbsp;Frames</a></li>
</ul>
<ul class="navList" id="allclasses_navbar_bottom">
<li><a href="../../../allclasses-noframe.html">All&nbsp;Classes</a></li>
</ul>
<div>
<script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_bottom");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script>
</div>
<div>
<ul class="subNavList">
<li>Summary:&nbsp;</li>
<li><a href="#nested.class.summary">Nested</a>&nbsp;|&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li>Constr&nbsp;|&nbsp;</li>
<li><a href="#method.summary">Method</a></li>
</ul>
<ul class="subNavList">
<li>Detail:&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li>Constr&nbsp;|&nbsp;</li>
<li><a href="#method.detail">Method</a></li>
</ul>
</div>
<a name="skip.navbar.bottom">
<!--   -->
</a></div>
<!-- ======== END OF BOTTOM NAVBAR ======= -->
<p class="legalCopy"><small>Copyright &#169; 2013&#x2013;2016. All rights reserved.</small></p>
</body>
</html>
