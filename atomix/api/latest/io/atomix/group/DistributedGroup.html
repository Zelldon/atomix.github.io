<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!-- NewPage -->
<html lang="en">
<head>
<!-- Generated by javadoc -->
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>DistributedGroup (Atomix API Reference (latest))</title>
<link rel="stylesheet" type="text/css" href="../../../stylesheet.css" title="Style">
<script type="text/javascript" src="../../../script.js"></script>
</head>
<body>
<script type="text/javascript"><!--
    try {
        if (location.href.indexOf('is-external=true') == -1) {
            parent.document.title="DistributedGroup (Atomix API Reference (latest))";
        }
    }
    catch(err) {
    }
//-->
var methods = {"i0":10,"i1":10,"i2":10,"i3":10,"i4":10,"i5":10,"i6":10,"i7":10,"i8":10,"i9":10,"i10":10,"i11":10};
var tabs = {65535:["t0","All Methods"],2:["t2","Instance Methods"],8:["t4","Concrete Methods"]};
var altColor = "altColor";
var rowColor = "rowColor";
var tableTab = "tableTab";
var activeTableTab = "activeTableTab";
</script>
<noscript>
<div>JavaScript is disabled on your browser.</div>
</noscript>
<!-- ========= START OF TOP NAVBAR ======= -->
<div class="topNav"><a name="navbar.top">
<!--   -->
</a>
<div class="skipNav"><a href="#skip.navbar.top" title="Skip navigation links">Skip navigation links</a></div>
<a name="navbar.top.firstrow">
<!--   -->
</a>
<ul class="navList" title="Navigation">
<li><a href="../../../overview-summary.html">Overview</a></li>
<li><a href="package-summary.html">Package</a></li>
<li class="navBarCell1Rev">Class</li>
<li><a href="class-use/DistributedGroup.html">Use</a></li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../../../deprecated-list.html">Deprecated</a></li>
<li><a href="../../../index-all.html">Index</a></li>
<li><a href="../../../help-doc.html">Help</a></li>
</ul>
</div>
<div class="subNav">
<ul class="navList">
<li>Prev&nbsp;Class</li>
<li><a href="../../../io/atomix/group/DistributedGroup.Config.html" title="class in io.atomix.group"><span class="typeNameLink">Next&nbsp;Class</span></a></li>
</ul>
<ul class="navList">
<li><a href="../../../index.html?io/atomix/group/DistributedGroup.html" target="_top">Frames</a></li>
<li><a href="DistributedGroup.html" target="_top">No&nbsp;Frames</a></li>
</ul>
<ul class="navList" id="allclasses_navbar_top">
<li><a href="../../../allclasses-noframe.html">All&nbsp;Classes</a></li>
</ul>
<div>
<script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_top");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script>
</div>
<div>
<ul class="subNavList">
<li>Summary:&nbsp;</li>
<li><a href="#nested.class.summary">Nested</a>&nbsp;|&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li><a href="#constructor.summary">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method.summary">Method</a></li>
</ul>
<ul class="subNavList">
<li>Detail:&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li><a href="#constructor.detail">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method.detail">Method</a></li>
</ul>
</div>
<a name="skip.navbar.top">
<!--   -->
</a></div>
<!-- ========= END OF TOP NAVBAR ========= -->
<!-- ======== START OF CLASS DATA ======== -->
<div class="header">
<div class="subTitle">io.atomix.group</div>
<h2 title="Class DistributedGroup" class="title">Class DistributedGroup</h2>
</div>
<div class="contentContainer">
<ul class="inheritance">
<li><a href="http://docs.oracle.com/javase/8/docs/api/java/lang/Object.html?is-external=true" title="class or interface in java.lang">java.lang.Object</a></li>
<li>
<ul class="inheritance">
<li><a href="../../../io/atomix/resource/AbstractResource.html" title="class in io.atomix.resource">io.atomix.resource.AbstractResource</a>&lt;<a href="../../../io/atomix/group/DistributedGroup.html" title="class in io.atomix.group">DistributedGroup</a>&gt;</li>
<li>
<ul class="inheritance">
<li>io.atomix.group.DistributedGroup</li>
</ul>
</li>
</ul>
</li>
</ul>
<div class="description">
<ul class="blockList">
<li class="blockList">
<dl>
<dt>All Implemented Interfaces:</dt>
<dd><a href="http://atomix.io/catalyst/api/latest/io/atomix/catalyst/util/Managed.html?is-external=true" title="class or interface in io.atomix.catalyst.util">Managed</a>&lt;<a href="../../../io/atomix/group/DistributedGroup.html" title="class in io.atomix.group">DistributedGroup</a>&gt;, <a href="../../../io/atomix/resource/Resource.html" title="interface in io.atomix.resource">Resource</a>&lt;<a href="../../../io/atomix/group/DistributedGroup.html" title="class in io.atomix.group">DistributedGroup</a>&gt;</dd>
</dl>
<hr>
<br>
<pre>public class <span class="typeNameLabel">DistributedGroup</span>
extends <a href="../../../io/atomix/resource/AbstractResource.html" title="class in io.atomix.resource">AbstractResource</a>&lt;<a href="../../../io/atomix/group/DistributedGroup.html" title="class in io.atomix.group">DistributedGroup</a>&gt;</pre>
<div class="block">Generic group abstraction for managing group membership, service discovery, leader election, and remote
 scheduling and execution.
 <p>
 The distributed group resource facilitates managing group membership within an Atomix cluster. Membership is
 managed by nodes <a href="../../../io/atomix/group/DistributedGroup.html#join--"><code>joining</code></a> and <a href="../../../io/atomix/group/LocalGroupMember.html#leave--"><code>leaving</code></a> the group, and instances
 of the group throughout the cluster are notified on changes to the structure of the group. Groups can elect a
 leader, and members can communicate directly with one another or through persistent queues.

 The distributed membership group resource facilitates managing group membership within the Atomix cluster.
 Each instance of a <code>DistributedGroup</code> resource represents a single <a href="../../../io/atomix/group/GroupMember.html" title="class in io.atomix.group"><code>GroupMember</code></a>.
 Members can <a href="../../../io/atomix/group/DistributedGroup.html#join--"><code>join()</code></a> and <a href="../../../io/atomix/group/LocalGroupMember.html#leave--"><code>LocalGroupMember.leave()</code></a> the group and be notified of other members
 <a href="../../../io/atomix/group/DistributedGroup.html#onJoin-java.util.function.Consumer-"><code>joining</code></a> and <a href="../../../io/atomix/group/DistributedGroup.html#onLeave-java.util.function.Consumer-"><code>leaving</code></a> the group. Members may leave the group
 either voluntarily or due to a failure or other disconnection from the cluster.
 <p>
 Groups membership is managed in a replicated state machine. When a member joins the group, the join request
 is replicated, the member is added to the group, and the state machine notifies instances of the
 <code>DistributedGroup</code> of the membership change. In the event that a group instance becomes disconnected from
 the cluster and its session times out, the replicated state machine will automatically remove the member
 from the group and notify the remaining instances of the group of the membership change.
 <p>
 To create a membership group resource, use the <code>DistributedGroup</code> class or constructor:
 <pre>
   <code>
   atomix.getGroup("my-group").thenAccept(group -&gt; {
     ...
   });
   </code>
 </pre>
 <h2>Configuration</h2>
 <code>DistributedGroup</code> instances can be configured to control <a href="../../../io/atomix/group/GroupMember.html#connection--"><code>communication</code></a>
 between members of the group and to define the behavior of how groups are <a href="../../../io/atomix/group/DistributedGroup.html#partitions--"><code>partitioned</code></a>.
 To configure groups, a <a href="../../../io/atomix/group/DistributedGroup.Config.html" title="class in io.atomix.group"><code>DistributedGroup.Config</code></a> and/or <a href="../../../io/atomix/group/DistributedGroup.Options.html" title="class in io.atomix.group"><code>DistributedGroup.Options</code></a> must be provided
 when constructing the initial group instance.
 <p>
 The <a href="../../../io/atomix/group/DistributedGroup.Config.html" title="class in io.atomix.group"><code>DistributedGroup.Config</code></a> controls the cluster-wide resource configuration. Only the configuration
 of the first instance of a group created <em>on any node in the cluster</em> will be applied to the group.
 If a group instance is created with <code>32</code> <a href="../../../io/atomix/group/DistributedGroup.Config.html#withPartitions-int-"><code>partitions</code></a>
 and later an instance is created with <code>16</code> partitions on another node, the latter instance will inherit
 the <code>32</code> partitions from the original instance.
 <pre>
   <code>
   DistributedGroup.Config config = new DistributedGroup.Config()
     .withPartitioner(RoundRobinPartitioner.class)
     .withPartitions(32);
   DistributedGroup group = atomix.getGroup("partitioned-group", config).get();
   </code>
 </pre>
 The <a href="../../../io/atomix/group/DistributedGroup.Options.html" title="class in io.atomix.group"><code>DistributedGroup.Options</code></a> define the configuration of the local <code>DistributedGroup</code> instance
 only. The group options will <em>not</em> be replicated to or applied on any other node in the cluster. However,
 group instances accessed via the <code>Atomix</code> API are static, so the options provided on the first instantiation
 of a group will be used for the local instance until the resource is deleted.
 <p>
 The primary role of <a href="../../../io/atomix/group/DistributedGroup.Options.html" title="class in io.atomix.group"><code>DistributedGroup.Options</code></a> is configuring the group's method of communication with
 other group instances around the cluster. In order to support direct messaging between members, the group
 must be configured with an <a href="http://atomix.io/catalyst/api/latest/io/atomix/catalyst/transport/Address.html?is-external=true" title="class or interface in io.atomix.catalyst.transport"><code>Address</code></a> to which to bind the server for communication.
 <pre>
   <code>
   DistributedGroup.Options options = new DistributedGroup.Options()
     .withAddress(new Address("localhost", 6000));
   DistributedGroup group = atomix.getGroup("message-group", options).get();
   </code>
 </pre>
 <h2>Joining the group</h2>
 When a new instance of the resource is created, it is initialized with an empty <a href="../../../io/atomix/group/DistributedGroup.html#members--"><code>members()</code></a> list
 as it is not yet a member of the group. Once the instance has been created, the user must join the group
 via <a href="../../../io/atomix/group/DistributedGroup.html#join--"><code>join()</code></a>:
 <pre>
   <code>
   group.join().thenAccept(member -&gt; {
     System.out.println("Joined with member ID: " + member.id());
   });
   </code>
 </pre>
 Once the group has been joined, the <a href="../../../io/atomix/group/DistributedGroup.html#members--"><code>members()</code></a> list provides an up-to-date view of the group which will
 be automatically updated as members join and leave the group. To be explicitly notified when a member joins or
 leaves the group, use the <a href="../../../io/atomix/group/DistributedGroup.html#onJoin-java.util.function.Consumer-"><code>onJoin(Consumer)</code></a> or <a href="../../../io/atomix/group/DistributedGroup.html#onLeave-java.util.function.Consumer-"><code>onLeave(Consumer)</code></a> event consumers respectively:
 <pre>
   <code>
   group.onJoin(member -&gt; {
     System.out.println(member.id() + " joined the group!");
   });
   </code>
 </pre>
 <h2>Listing the members in the group</h2>
 Users of the distributed group do not have to join the group to interact with it. For instance, while a server
 may participate in the group by joining it, a client may interact with the group just to get a list of available
 members. To access the list of group members, use the <a href="../../../io/atomix/group/DistributedGroup.html#members--"><code>members()</code></a> getter:
 <pre>
   <code>
   DistributedGroup group = atomix.getGroup("foo").get();
   for (GroupMember member : group.members()) {
     ...
   }
   </code>
 </pre>
 Once the group instance has been created, the group membership will be automatically updated each time the structure
 of the group changes. However, in the event that the client becomes disconnected from the cluster, it may not receive
 notifications of changes in the group structure.
 <h2>Member properties</h2>
 A group and each member of the group can be assigned arbitrary <a href="../../../io/atomix/group/GroupProperties.html" title="class in io.atomix.group"><code>properties</code></a>. Properties can
 be useful for associating various types of metadata with a group member. For instance, users might assign an
 <a href="http://atomix.io/catalyst/api/latest/io/atomix/catalyst/transport/Address.html?is-external=true" title="class or interface in io.atomix.catalyst.transport"><code>Address</code></a> as a property of a group member to indicate the address to which clients can connect to communicate
 with that member. Indeed, this is how direct messaging between group members is managed internally.
 <p>
 Properties are simple maps with non-null <a href="http://docs.oracle.com/javase/8/docs/api/java/lang/String.html?is-external=true" title="class or interface in java.lang"><code>String</code></a> keys and arbitrary serializable values. Properties
 can be set on the group or on a specific member of the group, and any node can assign and read properties for
 any member of a group.
 <pre>
   <code>
   DistributedGroup group = atomix.getGroup("properties-group").get();

   // Assign a name to the group and wait for the assignment to complete
   group.properties().set("name", "properties-group").join();

   // When a member joins the group, read the member's Address and connect to the member
   group.onJoin(member -&gt; {
     Address address = member.properties().get("address").get();
     client.connect(address).thenAccept(connection -&gt; {
       ...
     });
   });
   </code>
 </pre>
 Properties are guaranteed to be linearizable for all operations, meaning once a property of a group or member
 has been changed, all nodes are guaranteed to see that change when reading the property.
 <h2>Persistent members</h2>
 <code>DistributedGroup</code> supports a concept of persistent members that requires members to <em>explicitly</em>
 <a href="../../../io/atomix/group/LocalGroupMember.html#leave--"><code>leave</code></a> the group to be removed from it. Persistent member <a href="../../../io/atomix/group/GroupProperties.html" title="class in io.atomix.group"><code>properties</code></a>
 persist through failures, and enqueued <a href="../../../io/atomix/group/GroupTask.html" title="class in io.atomix.group"><code>tasks</code></a> will remain in a failed member's queue until the
 member recovers.
 <p>
 In order to support recovery, persistent members must be configured with a user-provided <a href="../../../io/atomix/group/GroupMember.html#id--"><code>member ID</code></a>.
 The member ID is provided when the member <a href="../../../io/atomix/group/DistributedGroup.html#join-java.lang.String-"><code>joins</code></a> the group, and providing a member ID is
 all that's required to create a persistent member.
 <pre>
   <code>
   DistributedGroup group = atomix.getGroup("persistent-members").get();
   LocalGroupMember memberA = group.join("a").get();
   LocalGroupMember memberB = group.join("b").get();
   </code>
 </pre>
 Persistent members are not limited to a single node. If a node crashes, any persistent members that existed
 on that node may rejoin the group on any other node. Persistent members rejoin simply by calling <a href="../../../io/atomix/group/DistributedGroup.html#join-java.lang.String-"><code>join(String)</code></a>
 with the unique member ID. Once a persistent member has rejoined the group, its session will be updated and any
 tasks remaining in the member's <a href="../../../io/atomix/group/GroupTaskQueue.html" title="class in io.atomix.group"><code>GroupTaskQueue</code></a> will be published to the member.
 <p>
 Persistent member state is retained <em>only</em> inside the group's replicated state machine and not on clients.
 From the perspective of <code>DistributedGroup</code> instances in a cluster, in the event that the node on which
 a persistent member is running fails, the member will <a href="../../../io/atomix/group/DistributedGroup.html#onLeave-java.util.function.Consumer-"><code>leave</code></a> the group. Once the persistent
 member rejoins the group, <a href="../../../io/atomix/group/DistributedGroup.html#onJoin-java.util.function.Consumer-"><code>onJoin(Consumer)</code></a> will be called again on each group instance in the cluster.
 <h2>Leader election</h2>
 The <code>DistributedGroup</code> resource facilitates leader election which can be used to coordinate a group by
 ensuring only a single member of the group performs some set of operations at any given time. Leader election
 is a core concept of membership groups, and because leader election is a low-overhead process, leaders are
 elected for each group automatically.
 <p>
 Leaders are elected using a fair policy. The first member to <a href="../../../io/atomix/group/DistributedGroup.html#join--"><code>join</code></a> a group will always become the
 initial group leader. Each unique leader in a group is associated with a <a href="../../../io/atomix/group/GroupElection.html#term--"><code>term</code></a>. The term is a
 globally unique, monotonically increasing token that can be used for fencing. Users can listen for changes in
 group terms and leaders with event listeners:
 <pre>
   <code>
   DistributedGroup group = atomix.getGroup("foo").get();
   group.election().onTerm(term -&gt; {
     ...
   });
   group.election().onElection(leader -&gt; {
     ...
   });
   </code>
 </pre>
 The <a href="../../../io/atomix/group/GroupElection.html#term--"><code>term</code></a> is guaranteed to be incremented prior to the election of a new <a href="../../../io/atomix/group/GroupElection.html#leader--"><code>leader</code></a>,
 and only a single leader for any given term will ever be elected. Each instance of a group is guaranteed to see
 terms and leaders progress monotonically, and no two leaders can exist in the same term. In that sense, the
 terminology and constrains of leader election in Atomix borrow heavily from the Raft algorithm that underlies it.
 <p>
 While terms and leaders are guaranteed to progress in the same order from the perspective of all clients of
 the resource, Atomix cannot guarantee that two leaders cannot exist at any given time. The group state machine
 will make a best effort attempt to ensure that all clients are notified of a term or leader change prior to the
 change being completed, but arbitrary process pauses due to garbage collection and other effects can cause a client's
 session to expire and thus prevent the client from being updated in real time. Only clients that can maintain their
 session are guaranteed to have a consistent view of the membership, term, and leader in the group at any given
 time.
 <p>
 To guard against inconsistencies resulting from arbitrary process pauses, clients can use the monotonically
 increasing term for coordination and managing optimistic access to external resources.
 <h2>Direct messaging</h2>
 Members of a group and group instances can communicate with one another through the direct messaging API,
 <a href="../../../io/atomix/group/GroupConnection.html" title="class in io.atomix.group"><code>GroupConnection</code></a>. Direct messaging between group members is considered <em>unreliable</em> and is
 done over the local node's configured <a href="http://atomix.io/catalyst/api/latest/io/atomix/catalyst/transport/Transport.html?is-external=true" title="class or interface in io.atomix.catalyst.transport"><code>Transport</code></a>. Messages between members
 of a group are ordered according only to the transport and are not guaranteed to be delivered. While request-reply
 can be used to achieve some level of assurance that messages are delivered to specific members of the group,
 direct message consumers should be idempotent and commutative.
 <p>
 In order to enable direct messaging for a group instance, the instance must be initialized with
 <a href="../../../io/atomix/group/DistributedGroup.Options.html" title="class in io.atomix.group"><code>DistributedGroup.Options</code></a> that define the <a href="http://atomix.io/catalyst/api/latest/io/atomix/catalyst/transport/Address.html?is-external=true" title="class or interface in io.atomix.catalyst.transport"><code>Address</code></a> to which to bind a <a href="http://atomix.io/catalyst/api/latest/io/atomix/catalyst/transport/Server.html?is-external=true" title="class or interface in io.atomix.catalyst.transport"><code>Server</code></a> for messaging.
 <pre>
   <code>
   DistributedGroup.Options options = new DistributedGroup.Options()
     .withAddress(new Address("localhost", 6000));
   DistributedGroup group = atomix.getGroup("message-group", options).get();
   </code>
 </pre>
 Once a group instance has been configured with an address for direct messaging, messages can be sent between
 group members using the <a href="../../../io/atomix/group/GroupConnection.html" title="class in io.atomix.group"><code>GroupConnection</code></a> for any member of the group. Messages sent between members must
 be associated with a <a href="http://docs.oracle.com/javase/8/docs/api/java/lang/String.html?is-external=true" title="class or interface in java.lang"><code>String</code></a> topic, and messages can be any value that is serializable by the group instance's
 <a href="http://atomix.io/catalyst/api/latest/io/atomix/catalyst/serializer/Serializer.html?is-external=true" title="class or interface in io.atomix.catalyst.serializer"><code>Serializer</code></a>.
 <pre>
   <code>
   group.member("foo").connection().send("hello", "World!").thenAccept(reply -&gt; {
     ...
   });
   </code>
 </pre>
 Direct messages can only be <em>received</em> by a <a href="../../../io/atomix/group/LocalGroupMember.html" title="class in io.atomix.group"><code>LocalGroupMember</code></a> which must be created by
 <a href="../../../io/atomix/group/DistributedGroup.html#join--"><code>joining</code></a> the group. Local members register a listener for a link topic on the joined member's
 <a href="../../../io/atomix/group/LocalGroupConnection.html" title="class in io.atomix.group"><code>LocalGroupConnection</code></a>. Message listeners are asynchronous. When a <a href="../../../io/atomix/group/GroupMessage.html" title="class in io.atomix.group"><code>GroupMessage</code></a> is received
 by a local member, the member can perform any processing it wishes and <a href="../../../io/atomix/group/GroupMessage.html#reply-java.lang.Object-"><code>reply</code></a>
 to the message or <a href="../../../io/atomix/group/GroupMessage.html#ack--"><code>acknowledge</code></a> completion of handling the message to send a response
 back to the sender.
 <pre>
   <code>
   // Join the group and run the given callback once successful
   group.join().thenAccept(member -&gt; {

     // Register a listener for the "hello" topic
     member.connection().onMessage("hello", message -&gt; {
       // Handle the message and reply
       handleMessage(message);
       message.reply("Hello world!");
     });

   });
   </code>
 </pre>
 It's critical that message listeners reply to messages, otherwise futures will be held in memory on the
 sending side of the <a href="../../../io/atomix/group/GroupConnection.html" title="class in io.atomix.group"><code>connection</code></a> until the sender or receiver is removed from the
 group.
 <h2>Task queues</h2>
 In addition to supporting direct messaging between members of the group, <code>DistributedGroup</code> provides
 mechanisms for reliable, persistent messaging. Tasks are arbitrary objects that can be sent between members
 of the group or to all members of a group by any node. In contrast to direct messaging, tasks are uni-directional
 in that <a href="../../../io/atomix/group/GroupTaskQueue.html" title="class in io.atomix.group"><code>task queues</code></a> only support sending a task but not receiving a reply. Tasks are
 submitted directly to the replicated state machine and once task submissions are complete are guaranteed to
 be persisted either until received and acknowledged by their target member or until that member leaves the
 cluster.
 <p>
 Task processing is event-driven and requires no polling on the receiving side of a task queue. When a task
 is received and persisted by the replicated state machine, if the member to which the task is sent is available
 for processing, the task will be pushed to that member through its open session. If the member is already
 processing another task, the task will be queued until all preceding tasks have been acked by the receiving
 member.
 <p>
 Tasks can be submitted to all members of a group or to a specific member through the object's associated
 <a href="../../../io/atomix/group/GroupTaskQueue.html" title="class in io.atomix.group"><code>GroupTaskQueue</code></a>. Once a task has completed processing, the task acknowledgement will be sent back
 to the sender. In the event a task fails processing, an exception will be thrown on the sender.
 <pre>
   <code>
   DistributedGroup group = atomix.getGroup("task-group").get();

   // Submit a task to all members of the group
   group.tasks().submit("doIt").whenComplete((result, error) -&gt; {
     if (error == null) {
       // All available members succeeded
     } else {
       // At least one member failed
     }
   });

   // Submit a task to a specific member of the group when it joins
   group.onJoin(member -&gt; {
     member.tasks().submit("doSetupTasks").whenComplete((result, error) -&gt; {
       if (error == null) {
         // The member received and processed the task
       } else {
         // The member did not receive the task or failed it
       }
     });
   });
   </code>
 </pre>
 When submitting a task to all members of the group via the group's <a href="../../../io/atomix/group/DistributedGroup.html#tasks--"><code>task queue</code></a>, the task will
 be enqueued for processing by all current members of the group. However, in the event an ephemeral member
 leaves the group (or crashes) during the processing of the task, the task will simply be skipped for that member.
 To ensure a member receives a task through a failure, use persistent members.
 <p>
 Tasks sent directly to specific members behave a bit differently. In the event that an ephemeral member leaves
 the group during the execution of a task, the task will be explicitly failed and an error will be returned
 to the task submitter.
 <p>
 Tasks are processed by <a href="../../../io/atomix/group/LocalGroupMember.html" title="class in io.atomix.group"><code>LocalGroupMember</code></a>s by registering a <a href="../../../io/atomix/group/LocalGroupTaskQueue.html#onTask-java.util.function.Consumer-"><code>task listener</code></a>
 on the member's queue. Once a member is done processing a task, it must <a href="../../../io/atomix/group/GroupTask.html#ack--"><code>ack</code></a> the task to
 fetch the next one from the cluster.
 <pre>
   <code>
   LocalGroupMember member = group.join("member-a").get();
   member.tasks().onTask(task -&gt; {
     doSetup();
     task.ack();
   });
   </code>
 </pre>
 Task receivers are free to take as long as is necessary to process a task. Task callbacks may be asynchronous.
 Members need only call <a href="../../../io/atomix/group/GroupTask.html#ack--"><code>GroupTask.ack()</code></a> once processing is complete. Tasks can also be explicitly
 <a href="../../../io/atomix/group/GroupTask.html#fail--"><code>fail</code></a>ed by receivers. Task failures will be sent back to the sender in the form of
 a <a href="../../../io/atomix/group/TaskFailedException.html" title="class in io.atomix.group"><code>TaskFailedException</code></a>.
 <pre>
   <code>
   member.tasks().onTask(task -&gt; {
     doSetupAsync().whenComplete((result, error) -&gt; {
       if (error == null) {
         task.ack();
       } else {
         task.fail();
       }
     });
   });
   </code>
 </pre>
 <h2>Partitioning</h2>
 Membership groups also provide features to aid in supporting replication via consistent hashing and partitioning.
 When a group is created, users can configure the group to support a particular number of partitions and replication
 factor. Partitioning can aid in hashing resources to specific members of the group, and the replication factor builds
 on partitions to aid in identifying multiple members per partition.
 <p>
 By default, groups are created with a single partition and replication factor of <code>1</code>. To configure the group
 for more partitions, provide a <a href="../../../io/atomix/group/DistributedGroup.Config.html" title="class in io.atomix.group"><code>DistributedGroup.Config</code></a> when creating the resource.
 <pre>
   <code>
   DistributedGroup.Config config = DistributedGroup.config()
     .withPartitions(32)
     .withVirtualNodes(200)
     .withReplicationFactor(3);
   DistributedGroup group = atomix.getGroup("foo", config);
   </code>
 </pre>
 Partitions are managed within a consistent hash ring. For each member of the cluster, <code>100</code> virtual nodes
 are created on the ring by default. This helps spread reduce hotspotting within the ring. For each partition, the
 partition is mapped to a set of members of the group by hashing the partition to a point on the ring. Once hashed
 to a point on the ring, the <code>n</code> members following that point are the replicas for that partition.
 <p>
 Partition features are accessed via the group's <a href="../../../io/atomix/group/GroupPartitions.html" title="class in io.atomix.group"><code>GroupPartitions</code></a> instance, which can be fetched via
 <a href="../../../io/atomix/group/DistributedGroup.html#partitions--"><code>partitions()</code></a>.
 <pre>
   <code>
   group.partitions().partition(1).members().forEach(m -&gt; ...);
   </code>
 </pre>
 Groups also aid in hashing objects to specific partitions and thus replicas within the group. Users can provide a
 <a href="../../../io/atomix/group/GroupPartitioner.html" title="interface in io.atomix.group"><code>GroupPartitioner</code></a> class in the <a href="../../../io/atomix/group/DistributedGroup.Options.html" title="class in io.atomix.group"><code>DistributedGroup.Options</code></a> when a group instance is first created on a node.
 The partitioner will be used to determine the partition to which an object maps within the current set of partitions
 when <a href="../../../io/atomix/group/GroupPartitions.html#partition-java.lang.Object-"><code>GroupPartitions.partition(Object)</code></a> is called.
 <pre>
   <code>
   group.partitions().partition("foo").members().forEach(m -&gt; m.send("foo"));
   </code>
 </pre>
 <h3>Partition migration</h3>
 Partitions change over time while members are added to or removed from the group. Each time a member is added or
 removed, the group state machine will reassign the minimal number of partitions necessary to balance the cluster,
 and <code>DistributedGroup</code> instances will be notified and updated automatically. Atomix guarantees that when a
 new member <a href="../../../io/atomix/group/DistributedGroup.html#join--"><code>joins</code></a> a group, all partition information on all connected group instances will be updated
 before the join completes. Similarly, when a member <a href="../../../io/atomix/group/LocalGroupMember.html#leave--"><code>leaves</code></a> the group, all partition
 information on all connected group instances are guaranteed to be updated before the operation completes.
 <p>
 Users can detect when partitions change membership to repartition data and update replicas. To listen for changes
 in a partition's membership, register a <a href="../../../io/atomix/group/GroupPartition.html#onMigration-java.util.function.Consumer-"><code>GroupPartition.onMigration(Consumer)</code></a> listener. The migration listener
 will be called any time a replica within the partition is moved to a new member, which can happen when nodes are
 added to or removed from the group. A <a href="../../../io/atomix/group/GroupPartitionMigration.html" title="class in io.atomix.group"><code>GroupPartitionMigration</code></a> will be provided to the migration callback
 indicating the source and destination of the partition migration.
 <pre>
   <code>
   group.partitions().partition(1).onMigration(migration -&gt; {
     // Send a message to the source replica and tell it to migrate its state to the target replica
     migration.source().connection().send("migrate", migration.target().id());
   });
   </code>
 </pre>
 The <a href="../../../io/atomix/group/GroupPartitions.html" title="class in io.atomix.group"><code>GroupPartitions</code></a> also provides a similar listener interface for listening for migrations of
 <em>all</em> partitions.
 <pre>
   <code>
   group.partitions().onMigration(migration -&gt; {
     // Send a message to the source replica and tell it to migrate its state to the target replica
     migration.source().connection().send("migrate-" + migration.partition().id(), migration.target().id());
   });
   </code>
 </pre>
 In some cases, a partition can be migrated from a non-existent replica to an existing member or vice-versa.
 For instance, if the <a href="../../../io/atomix/group/DistributedGroup.Config.html#withReplicationFactor-int-"><code>replication factor</code></a> is <code>3</code>
 and there are only two members in the group, when a third member is added all partitions will be migrated from
 a <code>null</code> third member to the new concrete third member. Group partitioners provide the maximum number
 of replicas possible given the current group configuration.
 <h3>Serialization</h3>
 Users are responsible for ensuring the serializability of tasks, messages, and properties set on the group
 and members of the group. Serialization is controlled by the group's <a href="http://atomix.io/catalyst/api/latest/io/atomix/catalyst/serializer/Serializer.html?is-external=true" title="class or interface in io.atomix.catalyst.serializer"><code>Serializer</code></a>
 which can be access via <a href="../../../io/atomix/resource/AbstractResource.html#serializer--"><code>AbstractResource.serializer()</code></a> or on the parent <code>Atomix</code> instance. Because objects are
 typically replicated throughout the cluster, <em>it's critical that any object sent from any node should be
 serializable by all other nodes</em>.
 <p>
 Users should register serializable types before performing any operations on the group.
 <pre>
   <code>
   DistributedGroup group = atomix.getGroup("group").get();
   group.serializer().register(User.class, UserSerializer.class);
   </code>
 </pre>
 For the best performance from serialization, it is recommended that serializable types be registered with
 unique type IDs. This allows the Catalyst <a href="http://atomix.io/catalyst/api/latest/io/atomix/catalyst/serializer/Serializer.html?is-external=true" title="class or interface in io.atomix.catalyst.serializer"><code>Serializer</code></a> to identify the
 type by its serialization ID rather than its class name. It's essential that the ID for a given type is
 the same all all nodes in the cluster.
 <pre>
   <code>
   group.serializer().register(User.class, 1, UserSerializer.class);
   </code>
 </pre>
 Users can also serialize <a href="http://docs.oracle.com/javase/8/docs/api/java/io/Serializable.html?is-external=true" title="class or interface in java.io"><code>Serializable</code></a> types by simply registering the class without any
 other serializer. Catalyst will attempt to use the optimal serializer based on the interfaces implemented
 by the class. Alternatively, type registration can be disabled altogether via <a href="http://atomix.io/catalyst/api/latest/io/atomix/catalyst/serializer/Serializer.html?is-external=true#disableWhitelist--" title="class or interface in io.atomix.catalyst.serializer"><code>Serializer.disableWhitelist()</code></a>,
 however this is not recommended as arbitrary deserialization of class names is slow and is a security risk.
 <h3>Implementation</h3>
 Group state is managed in a Copycat replicated <a href="http://atomix.io/copycat/api/latest/io/atomix/copycat/server/StateMachine.html?is-external=true" title="class or interface in io.atomix.copycat.server"><code>StateMachine</code></a>. When a
 <code>DistributedGroup</code> is created, an instance of the group state machine is created on each replica in
 the cluster. The state machine instance manages state for the specific membership group. When a member
 <a href="../../../io/atomix/group/DistributedGroup.html#join--"><code>joins</code></a> the group, a join request is sent to the cluster and logged and replicated before
 being applied to the group state machine. Once the join request has been committed and applied to the
 state machine, the group state is updated and existing group members are notified by
 <a href="http://atomix.io/copycat/api/latest/io/atomix/copycat/server/session/ServerSession.html?is-external=true#publish-java.lang.String-java.lang.Object-" title="class or interface in io.atomix.copycat.server.session"><code>publishing</code></a> state change
 notifications to open instances of the group. Membership change event notifications are received by all
 open instances of the resource.
 <p>
 Leader election is performed by the group state machine. When the first member joins the group, that
 member will automatically be assigned as the group member. Each time an additional member joins the group,
 the new member will be placed in a leader queue. In the event that the current group leader's
 <a href="http://atomix.io/copycat/api/latest/io/atomix/copycat/session/Session.html?is-external=true" title="class or interface in io.atomix.copycat.session"><code>Session</code></a> expires or is closed, the group state machine will assign a new
 leader by pulling from the leader queue and will publish an <code>elect</code> event to all remaining group
 members. Additionally, for each new leader of the group, the state machine will publish a <code>term</code> change
 event, providing a globally unique, monotonically increasing token uniquely associated with the new leader.
 <p>
 To track group membership, the group state machine tracks the state of the <a href="http://atomix.io/copycat/api/latest/io/atomix/copycat/session/Session.html?is-external=true" title="class or interface in io.atomix.copycat.session"><code>Session</code></a>
 associated with each open instance of the group. In the event that the session expires or is closed, the group
 member associated with that session will automatically be removed from the group and remaining instances
 of the group will be notified.
 <p>
 Partitions are determined by consistent hashing using the group's members and the configured partition strategy.
 Each time a member is added to the group, the member is added to a consistent hash ring. When a member leaves the
 group, the member is removed from the ring. Partitions are mapped to a point on the ring, and the <code>n</code> members
 following that point are the replicas for that partition. Virtual nodes are added to the ring to balance the
 membership.
 <p>
 The group state machine facilitates messaging and remote execution by routing serialize messages and callbacks
 to specific members of the group by publishing event messages to the desired resource session. Messages and
 callbacks are logged and replicated like any other state change in the group. Once a message or callback has
 been successfully published and received by the appropriate client, the associated commit is released from
 the state machine and will be removed from the log during compaction.
 <p>
 The group state machine manages compaction of the replicated log by tracking which state changes contribute to
 the state of the group at any given time. For instance, when a member joins the group, the commit that added the
 member to the group contributes to the group's state as long as the member remains a part of the group. Once the
 member leaves the group or its session is expired, the commit that created and remove the member no longer contribute
 to the group's state and are therefore released from the state machine and will be removed from the log during
 compaction.</div>
<dl>
<dt><span class="simpleTagLabel">Author:</span></dt>
<dd><a href="http://github.com/kuujo>Jordan Halterman</a></dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../io/atomix/group/GroupMember.html" title="class in io.atomix.group"><code>GroupMember</code></a></dd>
</dl>
</li>
</ul>
</div>
<div class="summary">
<ul class="blockList">
<li class="blockList">
<!-- ======== NESTED CLASS SUMMARY ======== -->
<ul class="blockList">
<li class="blockList"><a name="nested.class.summary">
<!--   -->
</a>
<h3>Nested Class Summary</h3>
<table class="memberSummary" border="0" cellpadding="3" cellspacing="0" summary="Nested Class Summary table, listing nested classes, and an explanation">
<caption><span>Nested Classes</span><span class="tabEnd">&nbsp;</span></caption>
<tr>
<th class="colFirst" scope="col">Modifier and Type</th>
<th class="colLast" scope="col">Class and Description</th>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static class&nbsp;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../io/atomix/group/DistributedGroup.Config.html" title="class in io.atomix.group">DistributedGroup.Config</a></span></code>
<div class="block">Group configuration.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static class&nbsp;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../io/atomix/group/DistributedGroup.Options.html" title="class in io.atomix.group">DistributedGroup.Options</a></span></code>
<div class="block">Group options.</div>
</td>
</tr>
</table>
<ul class="blockList">
<li class="blockList"><a name="nested.classes.inherited.from.class.io.atomix.resource.Resource">
<!--   -->
</a>
<h3>Nested classes/interfaces inherited from interface&nbsp;io.atomix.resource.<a href="../../../io/atomix/resource/Resource.html" title="interface in io.atomix.resource">Resource</a></h3>
<code><a href="../../../io/atomix/resource/Resource.State.html" title="enum in io.atomix.resource">Resource.State</a></code></li>
</ul>
</li>
</ul>
<!-- ======== CONSTRUCTOR SUMMARY ======== -->
<ul class="blockList">
<li class="blockList"><a name="constructor.summary">
<!--   -->
</a>
<h3>Constructor Summary</h3>
<table class="memberSummary" border="0" cellpadding="3" cellspacing="0" summary="Constructor Summary table, listing constructors, and an explanation">
<caption><span>Constructors</span><span class="tabEnd">&nbsp;</span></caption>
<tr>
<th class="colOne" scope="col">Constructor and Description</th>
</tr>
<tr class="altColor">
<td class="colOne"><code><span class="memberNameLink"><a href="../../../io/atomix/group/DistributedGroup.html#DistributedGroup-io.atomix.copycat.client.CopycatClient-java.util.Properties-">DistributedGroup</a></span>(<a href="http://atomix.io/copycat/api/latest/io/atomix/copycat/client/CopycatClient.html?is-external=true" title="class or interface in io.atomix.copycat.client">CopycatClient</a>&nbsp;client,
                <a href="http://docs.oracle.com/javase/8/docs/api/java/util/Properties.html?is-external=true" title="class or interface in java.util">Properties</a>&nbsp;options)</code>&nbsp;</td>
</tr>
</table>
</li>
</ul>
<!-- ========== METHOD SUMMARY =========== -->
<ul class="blockList">
<li class="blockList"><a name="method.summary">
<!--   -->
</a>
<h3>Method Summary</h3>
<table class="memberSummary" border="0" cellpadding="3" cellspacing="0" summary="Method Summary table, listing methods, and an explanation">
<caption><span id="t0" class="activeTableTab"><span>All Methods</span><span class="tabEnd">&nbsp;</span></span><span id="t2" class="tableTab"><span><a href="javascript:show(2);">Instance Methods</a></span><span class="tabEnd">&nbsp;</span></span><span id="t4" class="tableTab"><span><a href="javascript:show(8);">Concrete Methods</a></span><span class="tabEnd">&nbsp;</span></span></caption>
<tr>
<th class="colFirst" scope="col">Modifier and Type</th>
<th class="colLast" scope="col">Method and Description</th>
</tr>
<tr id="i0" class="altColor">
<td class="colFirst"><code><a href="../../../io/atomix/group/GroupElection.html" title="class in io.atomix.group">GroupElection</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../io/atomix/group/DistributedGroup.html#election--">election</a></span>()</code>
<div class="block">Returns the group election.</div>
</td>
</tr>
<tr id="i1" class="rowColor">
<td class="colFirst"><code><a href="http://docs.oracle.com/javase/8/docs/api/java/util/concurrent/CompletableFuture.html?is-external=true" title="class or interface in java.util.concurrent">CompletableFuture</a>&lt;<a href="../../../io/atomix/group/LocalGroupMember.html" title="class in io.atomix.group">LocalGroupMember</a>&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../io/atomix/group/DistributedGroup.html#join--">join</a></span>()</code>
<div class="block">Joins the instance to the membership group.</div>
</td>
</tr>
<tr id="i2" class="altColor">
<td class="colFirst"><code><a href="http://docs.oracle.com/javase/8/docs/api/java/util/concurrent/CompletableFuture.html?is-external=true" title="class or interface in java.util.concurrent">CompletableFuture</a>&lt;<a href="../../../io/atomix/group/LocalGroupMember.html" title="class in io.atomix.group">LocalGroupMember</a>&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../io/atomix/group/DistributedGroup.html#join-java.lang.String-">join</a></span>(<a href="http://docs.oracle.com/javase/8/docs/api/java/lang/String.html?is-external=true" title="class or interface in java.lang">String</a>&nbsp;memberId)</code>
<div class="block">Joins the instance to the membership group with a user-provided member ID.</div>
</td>
</tr>
<tr id="i3" class="rowColor">
<td class="colFirst"><code><a href="../../../io/atomix/group/GroupMember.html" title="class in io.atomix.group">GroupMember</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../io/atomix/group/DistributedGroup.html#member-java.lang.String-">member</a></span>(<a href="http://docs.oracle.com/javase/8/docs/api/java/lang/String.html?is-external=true" title="class or interface in java.lang">String</a>&nbsp;memberId)</code>
<div class="block">Gets a group member by ID.</div>
</td>
</tr>
<tr id="i4" class="altColor">
<td class="colFirst"><code><a href="http://docs.oracle.com/javase/8/docs/api/java/util/Collection.html?is-external=true" title="class or interface in java.util">Collection</a>&lt;<a href="../../../io/atomix/group/GroupMember.html" title="class in io.atomix.group">GroupMember</a>&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../io/atomix/group/DistributedGroup.html#members--">members</a></span>()</code>
<div class="block">Gets the collection of all members in the group.</div>
</td>
</tr>
<tr id="i5" class="rowColor">
<td class="colFirst"><code><a href="http://atomix.io/catalyst/api/latest/io/atomix/catalyst/util/Listener.html?is-external=true" title="class or interface in io.atomix.catalyst.util">Listener</a>&lt;<a href="../../../io/atomix/group/GroupMember.html" title="class in io.atomix.group">GroupMember</a>&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../io/atomix/group/DistributedGroup.html#onJoin-java.util.function.Consumer-">onJoin</a></span>(<a href="http://docs.oracle.com/javase/8/docs/api/java/util/function/Consumer.html?is-external=true" title="class or interface in java.util.function">Consumer</a>&lt;<a href="../../../io/atomix/group/GroupMember.html" title="class in io.atomix.group">GroupMember</a>&gt;&nbsp;listener)</code>
<div class="block">Adds a listener for members joining the group.</div>
</td>
</tr>
<tr id="i6" class="altColor">
<td class="colFirst"><code><a href="http://atomix.io/catalyst/api/latest/io/atomix/catalyst/util/Listener.html?is-external=true" title="class or interface in io.atomix.catalyst.util">Listener</a>&lt;<a href="../../../io/atomix/group/GroupMember.html" title="class in io.atomix.group">GroupMember</a>&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../io/atomix/group/DistributedGroup.html#onLeave-java.util.function.Consumer-">onLeave</a></span>(<a href="http://docs.oracle.com/javase/8/docs/api/java/util/function/Consumer.html?is-external=true" title="class or interface in java.util.function">Consumer</a>&lt;<a href="../../../io/atomix/group/GroupMember.html" title="class in io.atomix.group">GroupMember</a>&gt;&nbsp;listener)</code>
<div class="block">Adds a listener for members leaving the group.</div>
</td>
</tr>
<tr id="i7" class="rowColor">
<td class="colFirst"><code><a href="http://docs.oracle.com/javase/8/docs/api/java/util/concurrent/CompletableFuture.html?is-external=true" title="class or interface in java.util.concurrent">CompletableFuture</a>&lt;<a href="../../../io/atomix/group/DistributedGroup.html" title="class in io.atomix.group">DistributedGroup</a>&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../io/atomix/group/DistributedGroup.html#open--">open</a></span>()</code>
<div class="block">Opens the resource.</div>
</td>
</tr>
<tr id="i8" class="altColor">
<td class="colFirst"><code><a href="../../../io/atomix/group/DistributedGroup.Options.html" title="class in io.atomix.group">DistributedGroup.Options</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../io/atomix/group/DistributedGroup.html#options--">options</a></span>()</code>
<div class="block">Returns the resource options.</div>
</td>
</tr>
<tr id="i9" class="rowColor">
<td class="colFirst"><code><a href="../../../io/atomix/group/GroupPartitions.html" title="class in io.atomix.group">GroupPartitions</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../io/atomix/group/DistributedGroup.html#partitions--">partitions</a></span>()</code>
<div class="block">Returns the group partitions.</div>
</td>
</tr>
<tr id="i10" class="altColor">
<td class="colFirst"><code><a href="../../../io/atomix/group/GroupProperties.html" title="class in io.atomix.group">GroupProperties</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../io/atomix/group/DistributedGroup.html#properties--">properties</a></span>()</code>
<div class="block">Returns the group properties.</div>
</td>
</tr>
<tr id="i11" class="rowColor">
<td class="colFirst"><code><a href="../../../io/atomix/group/GroupTaskQueue.html" title="class in io.atomix.group">GroupTaskQueue</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../io/atomix/group/DistributedGroup.html#tasks--">tasks</a></span>()</code>
<div class="block">Returns the group task queue.</div>
</td>
</tr>
</table>
<ul class="blockList">
<li class="blockList"><a name="methods.inherited.from.class.io.atomix.resource.AbstractResource">
<!--   -->
</a>
<h3>Methods inherited from class&nbsp;io.atomix.resource.<a href="../../../io/atomix/resource/AbstractResource.html" title="class in io.atomix.resource">AbstractResource</a></h3>
<code><a href="../../../io/atomix/resource/AbstractResource.html#close--">close</a>, <a href="../../../io/atomix/resource/AbstractResource.html#config--">config</a>, <a href="../../../io/atomix/resource/AbstractResource.html#context--">context</a>, <a href="../../../io/atomix/resource/AbstractResource.html#delete--">delete</a>, <a href="../../../io/atomix/resource/AbstractResource.html#equals-java.lang.Object-">equals</a>, <a href="../../../io/atomix/resource/AbstractResource.html#hashCode--">hashCode</a>, <a href="../../../io/atomix/resource/AbstractResource.html#isClosed--">isClosed</a>, <a href="../../../io/atomix/resource/AbstractResource.html#isOpen--">isOpen</a>, <a href="../../../io/atomix/resource/AbstractResource.html#onStateChange-java.util.function.Consumer-">onStateChange</a>, <a href="../../../io/atomix/resource/AbstractResource.html#readConsistency--">readConsistency</a>, <a href="../../../io/atomix/resource/AbstractResource.html#serializer--">serializer</a>, <a href="../../../io/atomix/resource/AbstractResource.html#state--">state</a>, <a href="../../../io/atomix/resource/AbstractResource.html#toString--">toString</a>, <a href="../../../io/atomix/resource/AbstractResource.html#type--">type</a>, <a href="../../../io/atomix/resource/AbstractResource.html#with-io.atomix.resource.ReadConsistency-">with</a>, <a href="../../../io/atomix/resource/AbstractResource.html#with-io.atomix.resource.WriteConsistency-">with</a>, <a href="../../../io/atomix/resource/AbstractResource.html#writeConsistency--">writeConsistency</a></code></li>
</ul>
<ul class="blockList">
<li class="blockList"><a name="methods.inherited.from.class.java.lang.Object">
<!--   -->
</a>
<h3>Methods inherited from class&nbsp;java.lang.<a href="http://docs.oracle.com/javase/8/docs/api/java/lang/Object.html?is-external=true" title="class or interface in java.lang">Object</a></h3>
<code><a href="http://docs.oracle.com/javase/8/docs/api/java/lang/Object.html?is-external=true#getClass--" title="class or interface in java.lang">getClass</a>, <a href="http://docs.oracle.com/javase/8/docs/api/java/lang/Object.html?is-external=true#notify--" title="class or interface in java.lang">notify</a>, <a href="http://docs.oracle.com/javase/8/docs/api/java/lang/Object.html?is-external=true#notifyAll--" title="class or interface in java.lang">notifyAll</a>, <a href="http://docs.oracle.com/javase/8/docs/api/java/lang/Object.html?is-external=true#wait--" title="class or interface in java.lang">wait</a>, <a href="http://docs.oracle.com/javase/8/docs/api/java/lang/Object.html?is-external=true#wait-long-" title="class or interface in java.lang">wait</a>, <a href="http://docs.oracle.com/javase/8/docs/api/java/lang/Object.html?is-external=true#wait-long-int-" title="class or interface in java.lang">wait</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
<div class="details">
<ul class="blockList">
<li class="blockList">
<!-- ========= CONSTRUCTOR DETAIL ======== -->
<ul class="blockList">
<li class="blockList"><a name="constructor.detail">
<!--   -->
</a>
<h3>Constructor Detail</h3>
<a name="DistributedGroup-io.atomix.copycat.client.CopycatClient-java.util.Properties-">
<!--   -->
</a>
<ul class="blockListLast">
<li class="blockList">
<h4>DistributedGroup</h4>
<pre>public&nbsp;DistributedGroup(<a href="http://atomix.io/copycat/api/latest/io/atomix/copycat/client/CopycatClient.html?is-external=true" title="class or interface in io.atomix.copycat.client">CopycatClient</a>&nbsp;client,
                        <a href="http://docs.oracle.com/javase/8/docs/api/java/util/Properties.html?is-external=true" title="class or interface in java.util">Properties</a>&nbsp;options)</pre>
</li>
</ul>
</li>
</ul>
<!-- ============ METHOD DETAIL ========== -->
<ul class="blockList">
<li class="blockList"><a name="method.detail">
<!--   -->
</a>
<h3>Method Detail</h3>
<a name="options--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>options</h4>
<pre>public&nbsp;<a href="../../../io/atomix/group/DistributedGroup.Options.html" title="class in io.atomix.group">DistributedGroup.Options</a>&nbsp;options()</pre>
<div class="block"><span class="descfrmTypeLabel">Description copied from interface:&nbsp;<code><a href="../../../io/atomix/resource/Resource.html#options--">Resource</a></code></span></div>
<div class="block">Returns the resource options.</div>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code><a href="../../../io/atomix/resource/Resource.html#options--">options</a></code>&nbsp;in interface&nbsp;<code><a href="../../../io/atomix/resource/Resource.html" title="interface in io.atomix.resource">Resource</a>&lt;<a href="../../../io/atomix/group/DistributedGroup.html" title="class in io.atomix.group">DistributedGroup</a>&gt;</code></dd>
<dt><span class="overrideSpecifyLabel">Overrides:</span></dt>
<dd><code><a href="../../../io/atomix/resource/AbstractResource.html#options--">options</a></code>&nbsp;in class&nbsp;<code><a href="../../../io/atomix/resource/AbstractResource.html" title="class in io.atomix.resource">AbstractResource</a>&lt;<a href="../../../io/atomix/group/DistributedGroup.html" title="class in io.atomix.group">DistributedGroup</a>&gt;</code></dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The configured resource options.</dd>
</dl>
</li>
</ul>
<a name="properties--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>properties</h4>
<pre>public&nbsp;<a href="../../../io/atomix/group/GroupProperties.html" title="class in io.atomix.group">GroupProperties</a>&nbsp;properties()</pre>
<div class="block">Returns the group properties.</div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The group properties.</dd>
</dl>
</li>
</ul>
<a name="election--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>election</h4>
<pre>public&nbsp;<a href="../../../io/atomix/group/GroupElection.html" title="class in io.atomix.group">GroupElection</a>&nbsp;election()</pre>
<div class="block">Returns the group election.</div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The group election.</dd>
</dl>
</li>
</ul>
<a name="tasks--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>tasks</h4>
<pre>public&nbsp;<a href="../../../io/atomix/group/GroupTaskQueue.html" title="class in io.atomix.group">GroupTaskQueue</a>&nbsp;tasks()</pre>
<div class="block">Returns the group task queue.</div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The group task queue.</dd>
</dl>
</li>
</ul>
<a name="partitions--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>partitions</h4>
<pre>public&nbsp;<a href="../../../io/atomix/group/GroupPartitions.html" title="class in io.atomix.group">GroupPartitions</a>&nbsp;partitions()</pre>
<div class="block">Returns the group partitions.</div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The group partitions.</dd>
</dl>
</li>
</ul>
<a name="member-java.lang.String-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>member</h4>
<pre>public&nbsp;<a href="../../../io/atomix/group/GroupMember.html" title="class in io.atomix.group">GroupMember</a>&nbsp;member(<a href="http://docs.oracle.com/javase/8/docs/api/java/lang/String.html?is-external=true" title="class or interface in java.lang">String</a>&nbsp;memberId)</pre>
<div class="block">Gets a group member by ID.
 <p>
 If the member with the given ID has not <a href="../../../io/atomix/group/DistributedGroup.html#join--"><code>joined</code></a> the membership group, the resulting
 <a href="../../../io/atomix/group/GroupMember.html" title="class in io.atomix.group"><code>GroupMember</code></a> will be <code>null</code>.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>memberId</code> - The member ID for which to return a <a href="../../../io/atomix/group/GroupMember.html" title="class in io.atomix.group"><code>GroupMember</code></a>.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The member with the given <code>memberId</code> or <code>null</code> if it is not a known member of the group.</dd>
</dl>
</li>
</ul>
<a name="members--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>members</h4>
<pre>public&nbsp;<a href="http://docs.oracle.com/javase/8/docs/api/java/util/Collection.html?is-external=true" title="class or interface in java.util">Collection</a>&lt;<a href="../../../io/atomix/group/GroupMember.html" title="class in io.atomix.group">GroupMember</a>&gt;&nbsp;members()</pre>
<div class="block">Gets the collection of all members in the group.
 <p>
 The group members are fetched from the cluster. If any <a href="../../../io/atomix/group/GroupMember.html" title="class in io.atomix.group"><code>GroupMember</code></a> instances have been referenced
 by this membership group instance, the same object will be returned for that member.
 <p>
 This method returns a <a href="http://docs.oracle.com/javase/8/docs/api/java/util/concurrent/CompletableFuture.html?is-external=true" title="class or interface in java.util.concurrent"><code>CompletableFuture</code></a> which can be used to block until the operation completes
 or to be notified in a separate thread once the operation completes. To block until the operation completes,
 use the <a href="http://docs.oracle.com/javase/8/docs/api/java/util/concurrent/CompletableFuture.html?is-external=true#join--" title="class or interface in java.util.concurrent"><code>CompletableFuture.join()</code></a> method to block the calling thread:
 <pre>
   <code>
   Collection&lt;GroupMember&gt; members = group.members().get();
   </code>
 </pre>
 Alternatively, to execute the operation asynchronous and be notified once the lock is acquired in a different
 thread, use one of the many completable future callbacks:
 <pre>
   <code>
   group.members().thenAccept(members -&gt; {
     members.forEach(member -&gt; {
       member.send("test", "Hello world!");
     });
   });
   </code>
 </pre></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The collection of all members in the group.</dd>
</dl>
</li>
</ul>
<a name="join--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>join</h4>
<pre>public&nbsp;<a href="http://docs.oracle.com/javase/8/docs/api/java/util/concurrent/CompletableFuture.html?is-external=true" title="class or interface in java.util.concurrent">CompletableFuture</a>&lt;<a href="../../../io/atomix/group/LocalGroupMember.html" title="class in io.atomix.group">LocalGroupMember</a>&gt;&nbsp;join()</pre>
<div class="block">Joins the instance to the membership group.
 <p>
 When this instance joins the membership group, the membership lists of this and all other instances
 in the group are guaranteed to be updated <em>before</em> the <a href="http://docs.oracle.com/javase/8/docs/api/java/util/concurrent/CompletableFuture.html?is-external=true" title="class or interface in java.util.concurrent"><code>CompletableFuture</code></a> returned by
 this method is completed. Once this instance has joined the group, the returned future will be completed
 with the <a href="../../../io/atomix/group/GroupMember.html" title="class in io.atomix.group"><code>GroupMember</code></a> instance for this member.
 <p>
 This method returns a <a href="http://docs.oracle.com/javase/8/docs/api/java/util/concurrent/CompletableFuture.html?is-external=true" title="class or interface in java.util.concurrent"><code>CompletableFuture</code></a> which can be used to block until the operation completes
 or to be notified in a separate thread once the operation completes. To block until the operation completes,
 use the <a href="http://docs.oracle.com/javase/8/docs/api/java/util/concurrent/CompletableFuture.html?is-external=true#join--" title="class or interface in java.util.concurrent"><code>CompletableFuture.join()</code></a> method to block the calling thread:
 <pre>
   <code>
   group.join().join();
   </code>
 </pre>
 Alternatively, to execute the operation asynchronous and be notified once the lock is acquired in a different
 thread, use one of the many completable future callbacks:
 <pre>
   <code>
   group.join().thenAccept(thisMember -&gt; System.out.println("This member is: " + thisMember.id()));
   </code>
 </pre></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>A completable future to be completed once the member has joined.</dd>
</dl>
</li>
</ul>
<a name="join-java.lang.String-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>join</h4>
<pre>public&nbsp;<a href="http://docs.oracle.com/javase/8/docs/api/java/util/concurrent/CompletableFuture.html?is-external=true" title="class or interface in java.util.concurrent">CompletableFuture</a>&lt;<a href="../../../io/atomix/group/LocalGroupMember.html" title="class in io.atomix.group">LocalGroupMember</a>&gt;&nbsp;join(<a href="http://docs.oracle.com/javase/8/docs/api/java/lang/String.html?is-external=true" title="class or interface in java.lang">String</a>&nbsp;memberId)</pre>
<div class="block">Joins the instance to the membership group with a user-provided member ID.
 <p>
 When this instance joins the membership group, the membership lists of this and all other instances
 in the group are guaranteed to be updated <em>before</em> the <a href="http://docs.oracle.com/javase/8/docs/api/java/util/concurrent/CompletableFuture.html?is-external=true" title="class or interface in java.util.concurrent"><code>CompletableFuture</code></a> returned by
 this method is completed. Once this instance has joined the group, the returned future will be completed
 with the <a href="../../../io/atomix/group/GroupMember.html" title="class in io.atomix.group"><code>GroupMember</code></a> instance for this member.
 <p>
 This method returns a <a href="http://docs.oracle.com/javase/8/docs/api/java/util/concurrent/CompletableFuture.html?is-external=true" title="class or interface in java.util.concurrent"><code>CompletableFuture</code></a> which can be used to block until the operation completes
 or to be notified in a separate thread once the operation completes. To block until the operation completes,
 use the <a href="http://docs.oracle.com/javase/8/docs/api/java/util/concurrent/CompletableFuture.html?is-external=true#join--" title="class or interface in java.util.concurrent"><code>CompletableFuture.join()</code></a> method to block the calling thread:
 <pre>
   <code>
   group.join().join();
   </code>
 </pre>
 Alternatively, to execute the operation asynchronous and be notified once the lock is acquired in a different
 thread, use one of the many completable future callbacks:
 <pre>
   <code>
   group.join().thenAccept(thisMember -&gt; System.out.println("This member is: " + thisMember.id()));
   </code>
 </pre></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>memberId</code> - The unique member ID to assign to the member.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>A completable future to be completed once the member has joined.</dd>
</dl>
</li>
</ul>
<a name="onJoin-java.util.function.Consumer-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>onJoin</h4>
<pre>public&nbsp;<a href="http://atomix.io/catalyst/api/latest/io/atomix/catalyst/util/Listener.html?is-external=true" title="class or interface in io.atomix.catalyst.util">Listener</a>&lt;<a href="../../../io/atomix/group/GroupMember.html" title="class in io.atomix.group">GroupMember</a>&gt;&nbsp;onJoin(<a href="http://docs.oracle.com/javase/8/docs/api/java/util/function/Consumer.html?is-external=true" title="class or interface in java.util.function">Consumer</a>&lt;<a href="../../../io/atomix/group/GroupMember.html" title="class in io.atomix.group">GroupMember</a>&gt;&nbsp;listener)</pre>
<div class="block">Adds a listener for members joining the group.
 <p>
 The provided <a href="http://docs.oracle.com/javase/8/docs/api/java/util/function/Consumer.html?is-external=true" title="class or interface in java.util.function"><code>Consumer</code></a> will be called each time a member joins the group. Note that
 the join consumer will be called before the joining member's <a href="../../../io/atomix/group/DistributedGroup.html#join--"><code>join()</code></a> completes.
 <p>
 The returned <a href="http://atomix.io/catalyst/api/latest/io/atomix/catalyst/util/Listener.html?is-external=true" title="class or interface in io.atomix.catalyst.util"><code>Listener</code></a> can be used to <a href="http://atomix.io/catalyst/api/latest/io/atomix/catalyst/util/Listener.html?is-external=true#close--" title="class or interface in io.atomix.catalyst.util"><code>unregister</code></a> the listener
 when its use if finished.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>listener</code> - The join listener.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The listener context.</dd>
</dl>
</li>
</ul>
<a name="onLeave-java.util.function.Consumer-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>onLeave</h4>
<pre>public&nbsp;<a href="http://atomix.io/catalyst/api/latest/io/atomix/catalyst/util/Listener.html?is-external=true" title="class or interface in io.atomix.catalyst.util">Listener</a>&lt;<a href="../../../io/atomix/group/GroupMember.html" title="class in io.atomix.group">GroupMember</a>&gt;&nbsp;onLeave(<a href="http://docs.oracle.com/javase/8/docs/api/java/util/function/Consumer.html?is-external=true" title="class or interface in java.util.function">Consumer</a>&lt;<a href="../../../io/atomix/group/GroupMember.html" title="class in io.atomix.group">GroupMember</a>&gt;&nbsp;listener)</pre>
<div class="block">Adds a listener for members leaving the group.
 <p>
 The provided <a href="http://docs.oracle.com/javase/8/docs/api/java/util/function/Consumer.html?is-external=true" title="class or interface in java.util.function"><code>Consumer</code></a> will be called each time a member leaves the group. Members can
 leave the group either voluntarily or by crashing or otherwise becoming disconnected from the
 cluster for longer than their session timeout. Note that the leave consumer will be called before
 the leaving member's <a href="../../../io/atomix/group/LocalGroupMember.html#leave--"><code>LocalGroupMember.leave()</code></a> completes.
 <p>
 The returned <a href="http://atomix.io/catalyst/api/latest/io/atomix/catalyst/util/Listener.html?is-external=true" title="class or interface in io.atomix.catalyst.util"><code>Listener</code></a> can be used to <a href="http://atomix.io/catalyst/api/latest/io/atomix/catalyst/util/Listener.html?is-external=true#close--" title="class or interface in io.atomix.catalyst.util"><code>unregister</code></a> the listener
 when its use if finished.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>listener</code> - The leave listener.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The listener context.</dd>
</dl>
</li>
</ul>
<a name="open--">
<!--   -->
</a>
<ul class="blockListLast">
<li class="blockList">
<h4>open</h4>
<pre>public&nbsp;<a href="http://docs.oracle.com/javase/8/docs/api/java/util/concurrent/CompletableFuture.html?is-external=true" title="class or interface in java.util.concurrent">CompletableFuture</a>&lt;<a href="../../../io/atomix/group/DistributedGroup.html" title="class in io.atomix.group">DistributedGroup</a>&gt;&nbsp;open()</pre>
<div class="block"><span class="descfrmTypeLabel">Description copied from interface:&nbsp;<code><a href="../../../io/atomix/resource/Resource.html#open--">Resource</a></code></span></div>
<div class="block">Opens the resource.
 <p>
 Once the resource is opened, the resource will be transitioned to the <a href="../../../io/atomix/resource/Resource.State.html#CONNECTED"><code>Resource.State.CONNECTED</code></a> state
 and the returned <a href="http://docs.oracle.com/javase/8/docs/api/java/util/concurrent/CompletableFuture.html?is-external=true" title="class or interface in java.util.concurrent"><code>CompletableFuture</code></a> will be completed.</div>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code><a href="http://atomix.io/catalyst/api/latest/io/atomix/catalyst/util/Managed.html?is-external=true#open--" title="class or interface in io.atomix.catalyst.util">open</a></code>&nbsp;in interface&nbsp;<code><a href="http://atomix.io/catalyst/api/latest/io/atomix/catalyst/util/Managed.html?is-external=true" title="class or interface in io.atomix.catalyst.util">Managed</a>&lt;<a href="../../../io/atomix/group/DistributedGroup.html" title="class in io.atomix.group">DistributedGroup</a>&gt;</code></dd>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code><a href="../../../io/atomix/resource/Resource.html#open--">open</a></code>&nbsp;in interface&nbsp;<code><a href="../../../io/atomix/resource/Resource.html" title="interface in io.atomix.resource">Resource</a>&lt;<a href="../../../io/atomix/group/DistributedGroup.html" title="class in io.atomix.group">DistributedGroup</a>&gt;</code></dd>
<dt><span class="overrideSpecifyLabel">Overrides:</span></dt>
<dd><code><a href="../../../io/atomix/resource/AbstractResource.html#open--">open</a></code>&nbsp;in class&nbsp;<code><a href="../../../io/atomix/resource/AbstractResource.html" title="class in io.atomix.resource">AbstractResource</a>&lt;<a href="../../../io/atomix/group/DistributedGroup.html" title="class in io.atomix.group">DistributedGroup</a>&gt;</code></dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>A completable future to be completed once the resource is opened.</dd>
</dl>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</div>
<!-- ========= END OF CLASS DATA ========= -->
<!-- ======= START OF BOTTOM NAVBAR ====== -->
<div class="bottomNav"><a name="navbar.bottom">
<!--   -->
</a>
<div class="skipNav"><a href="#skip.navbar.bottom" title="Skip navigation links">Skip navigation links</a></div>
<a name="navbar.bottom.firstrow">
<!--   -->
</a>
<ul class="navList" title="Navigation">
<li><a href="../../../overview-summary.html">Overview</a></li>
<li><a href="package-summary.html">Package</a></li>
<li class="navBarCell1Rev">Class</li>
<li><a href="class-use/DistributedGroup.html">Use</a></li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../../../deprecated-list.html">Deprecated</a></li>
<li><a href="../../../index-all.html">Index</a></li>
<li><a href="../../../help-doc.html">Help</a></li>
</ul>
</div>
<div class="subNav">
<ul class="navList">
<li>Prev&nbsp;Class</li>
<li><a href="../../../io/atomix/group/DistributedGroup.Config.html" title="class in io.atomix.group"><span class="typeNameLink">Next&nbsp;Class</span></a></li>
</ul>
<ul class="navList">
<li><a href="../../../index.html?io/atomix/group/DistributedGroup.html" target="_top">Frames</a></li>
<li><a href="DistributedGroup.html" target="_top">No&nbsp;Frames</a></li>
</ul>
<ul class="navList" id="allclasses_navbar_bottom">
<li><a href="../../../allclasses-noframe.html">All&nbsp;Classes</a></li>
</ul>
<div>
<script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_bottom");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script>
</div>
<div>
<ul class="subNavList">
<li>Summary:&nbsp;</li>
<li><a href="#nested.class.summary">Nested</a>&nbsp;|&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li><a href="#constructor.summary">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method.summary">Method</a></li>
</ul>
<ul class="subNavList">
<li>Detail:&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li><a href="#constructor.detail">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method.detail">Method</a></li>
</ul>
</div>
<a name="skip.navbar.bottom">
<!--   -->
</a></div>
<!-- ======== END OF BOTTOM NAVBAR ======= -->
<p class="legalCopy"><small>Copyright &#169; 2013&#x2013;2016. All rights reserved.</small></p>
</body>
</html>
