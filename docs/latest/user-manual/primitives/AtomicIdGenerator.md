---
layout: user-manual
project: atomix
menu: user-manual
title: AtomicIdGenerator
---

The [`AtomicIdGenerator`][AtomicIdGenerator] primitive is a simplistic generator of globally unique `long` identifiers. Identifiers generated by an `AtomicIdGenerator` are guaranteed to be unique but not monotonically increasing.

## Configuration

The [`AtomicIdGenerator`][AtomicIdGenerator] can be configured programmatically using the [`AtomicIdGeneratorBuilder`][AtomicIdGeneratorBuilder]. To create a new counter builder, use the `atomicIdGeneratorBuilder` method, passing the name of the counter to construct:

```java
AtomicIdGeneratorBuilder idGeneratorBuilder = atomix.atomicIdGeneratorBuilder("my-id-generator");
```

The counter can be configured with a `PrimitiveProtocol` to use to replicate changes. Since `AtomicIdGenerator` is a consistent primitive, the only protocols supported are:
* [`MultiRaftProtocol`][MultiRaftProtocol]
* [`MultiPrimaryProtocol`][MultiPrimaryProtocol]

Additionally, when using partitioned protocols, the counter will be replicated only within a single partition for consistency.

```java
AtomicIdGenerator idGenerator = atomix.atomicIdGeneratorBuilder("my-id-generator")
  .withProtocol(MultiRaftProtocol.builder()
    .withReadConsistency(ReadConsistency.LINEARIZABLE)
    .build())
  .build();
```

Atomic counters can also be configured in configuration files. To configure an atomic counter primitive, use the `atomic-id-generator` primitive type:

`atomix.conf`

```hocon
primitives.my-id-generator {
  type: atomic-id-generator
  protocol {
    type: multi-raft
    group: raft
    read-consistency: linearizable
  }
}
```

To get an instance of the pre-configured counter, use the `getAtomicIdGenerator` method:

```java
AtomicIdGenerator idGenerator = atomix.getAtomicIdGenerator("my-id-generator");
```

The counter's protocol and configuration will be loaded from the Atomix configuration files.

## Operation

The [`AtomicIdGenerator`][AtomicIdGenerator] provides a single method for retrieving a globally unique identifier called `nextId`:

```java
AtomicIdGenerator idGenerator = atomix.atomicIdGeneratorBuilder("my-id-generator")
  .withProtocol(MultiRaftProtocol.builder()
    .withReadConsistency(ReadConsistency.LINEARIZABLE)
    .build())
  .build();

long id = idGenerator.nextId();
```

The ID generator works by reserving a batch of sequential identifiers for the session. This means users may see sequential identifiers, but note that the ID generator does not _guarantee_ identifiers will be sequential. Once the batch of reserved identifiers is exhausted, a new batch at a higher sequence number will be reserved.

As with all Atomix primitives, an asynchronous analogue of the ID generator API - [`AsyncAtomicIdGenerator`][AsyncAtomicIdGenerator] - can be retrieved by calling the `async()` method:

```java
AsyncAtomicIdGenerator asyncIdGenerator = idGenerator.async();

asyncIdGenerator.nextId().thenAccept(id -> {
  ...
});
```

The asynchronous API uses [`CompletableFuture`][CompletableFuture]s to notify the client once an operation is complete. The thread model provided by all Atomix protocols guarantees `CompletableFuture` callbacks will always be executed on the same thread unless a thread is blocked by a prior primitive operation. Additionally, `CompletableFuture`s will be completed in program order. In other words, if an operation `A` was performed before operation `B` on the client, the future for operation `A` will always be completed before the future for operation `B`.

## Cleanup

While a counter is in use, Atomix may consume some network, memory, and disk resources to manage the ID generator. To free up those resources, users should call the `close()` method to allow Atomix to garbage collect the instance.

```java
idGenerator.close();
```

{% include common-links.html %}
